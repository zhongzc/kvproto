// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pdpb.proto

#ifndef PROTOBUF_pdpb_2eproto__INCLUDED
#define PROTOBUF_pdpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "eraftpb.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_pdpb_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[56];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRequestHeaderImpl();
void InitDefaultsRequestHeader();
void InitDefaultsResponseHeaderImpl();
void InitDefaultsResponseHeader();
void InitDefaultsErrorImpl();
void InitDefaultsError();
void InitDefaultsTsoRequestImpl();
void InitDefaultsTsoRequest();
void InitDefaultsTimestampImpl();
void InitDefaultsTimestamp();
void InitDefaultsTsoResponseImpl();
void InitDefaultsTsoResponse();
void InitDefaultsBootstrapRequestImpl();
void InitDefaultsBootstrapRequest();
void InitDefaultsBootstrapResponseImpl();
void InitDefaultsBootstrapResponse();
void InitDefaultsIsBootstrappedRequestImpl();
void InitDefaultsIsBootstrappedRequest();
void InitDefaultsIsBootstrappedResponseImpl();
void InitDefaultsIsBootstrappedResponse();
void InitDefaultsAllocIDRequestImpl();
void InitDefaultsAllocIDRequest();
void InitDefaultsAllocIDResponseImpl();
void InitDefaultsAllocIDResponse();
void InitDefaultsGetStoreRequestImpl();
void InitDefaultsGetStoreRequest();
void InitDefaultsGetStoreResponseImpl();
void InitDefaultsGetStoreResponse();
void InitDefaultsPutStoreRequestImpl();
void InitDefaultsPutStoreRequest();
void InitDefaultsPutStoreResponseImpl();
void InitDefaultsPutStoreResponse();
void InitDefaultsGetAllStoresRequestImpl();
void InitDefaultsGetAllStoresRequest();
void InitDefaultsGetAllStoresResponseImpl();
void InitDefaultsGetAllStoresResponse();
void InitDefaultsGetRegionRequestImpl();
void InitDefaultsGetRegionRequest();
void InitDefaultsGetRegionResponseImpl();
void InitDefaultsGetRegionResponse();
void InitDefaultsGetRegionByIDRequestImpl();
void InitDefaultsGetRegionByIDRequest();
void InitDefaultsGetClusterConfigRequestImpl();
void InitDefaultsGetClusterConfigRequest();
void InitDefaultsGetClusterConfigResponseImpl();
void InitDefaultsGetClusterConfigResponse();
void InitDefaultsPutClusterConfigRequestImpl();
void InitDefaultsPutClusterConfigRequest();
void InitDefaultsPutClusterConfigResponseImpl();
void InitDefaultsPutClusterConfigResponse();
void InitDefaultsMemberImpl();
void InitDefaultsMember();
void InitDefaultsGetMembersRequestImpl();
void InitDefaultsGetMembersRequest();
void InitDefaultsGetMembersResponseImpl();
void InitDefaultsGetMembersResponse();
void InitDefaultsPeerStatsImpl();
void InitDefaultsPeerStats();
void InitDefaultsRegionHeartbeatRequestImpl();
void InitDefaultsRegionHeartbeatRequest();
void InitDefaultsChangePeerImpl();
void InitDefaultsChangePeer();
void InitDefaultsTransferLeaderImpl();
void InitDefaultsTransferLeader();
void InitDefaultsMergeImpl();
void InitDefaultsMerge();
void InitDefaultsSplitRegionImpl();
void InitDefaultsSplitRegion();
void InitDefaultsRegionHeartbeatResponseImpl();
void InitDefaultsRegionHeartbeatResponse();
void InitDefaultsAskSplitRequestImpl();
void InitDefaultsAskSplitRequest();
void InitDefaultsAskSplitResponseImpl();
void InitDefaultsAskSplitResponse();
void InitDefaultsReportSplitRequestImpl();
void InitDefaultsReportSplitRequest();
void InitDefaultsReportSplitResponseImpl();
void InitDefaultsReportSplitResponse();
void InitDefaultsAskBatchSplitRequestImpl();
void InitDefaultsAskBatchSplitRequest();
void InitDefaultsSplitIDImpl();
void InitDefaultsSplitID();
void InitDefaultsAskBatchSplitResponseImpl();
void InitDefaultsAskBatchSplitResponse();
void InitDefaultsReportBatchSplitRequestImpl();
void InitDefaultsReportBatchSplitRequest();
void InitDefaultsReportBatchSplitResponseImpl();
void InitDefaultsReportBatchSplitResponse();
void InitDefaultsTimeIntervalImpl();
void InitDefaultsTimeInterval();
void InitDefaultsStoreStatsImpl();
void InitDefaultsStoreStats();
void InitDefaultsStoreHeartbeatRequestImpl();
void InitDefaultsStoreHeartbeatRequest();
void InitDefaultsStoreHeartbeatResponseImpl();
void InitDefaultsStoreHeartbeatResponse();
void InitDefaultsScatterRegionRequestImpl();
void InitDefaultsScatterRegionRequest();
void InitDefaultsScatterRegionResponseImpl();
void InitDefaultsScatterRegionResponse();
void InitDefaultsGetGCSafePointRequestImpl();
void InitDefaultsGetGCSafePointRequest();
void InitDefaultsGetGCSafePointResponseImpl();
void InitDefaultsGetGCSafePointResponse();
void InitDefaultsUpdateGCSafePointRequestImpl();
void InitDefaultsUpdateGCSafePointRequest();
void InitDefaultsUpdateGCSafePointResponseImpl();
void InitDefaultsUpdateGCSafePointResponse();
void InitDefaultsSyncRegionRequestImpl();
void InitDefaultsSyncRegionRequest();
void InitDefaultsSyncRegionResponseImpl();
void InitDefaultsSyncRegionResponse();
inline void InitDefaults() {
  InitDefaultsRequestHeader();
  InitDefaultsResponseHeader();
  InitDefaultsError();
  InitDefaultsTsoRequest();
  InitDefaultsTimestamp();
  InitDefaultsTsoResponse();
  InitDefaultsBootstrapRequest();
  InitDefaultsBootstrapResponse();
  InitDefaultsIsBootstrappedRequest();
  InitDefaultsIsBootstrappedResponse();
  InitDefaultsAllocIDRequest();
  InitDefaultsAllocIDResponse();
  InitDefaultsGetStoreRequest();
  InitDefaultsGetStoreResponse();
  InitDefaultsPutStoreRequest();
  InitDefaultsPutStoreResponse();
  InitDefaultsGetAllStoresRequest();
  InitDefaultsGetAllStoresResponse();
  InitDefaultsGetRegionRequest();
  InitDefaultsGetRegionResponse();
  InitDefaultsGetRegionByIDRequest();
  InitDefaultsGetClusterConfigRequest();
  InitDefaultsGetClusterConfigResponse();
  InitDefaultsPutClusterConfigRequest();
  InitDefaultsPutClusterConfigResponse();
  InitDefaultsMember();
  InitDefaultsGetMembersRequest();
  InitDefaultsGetMembersResponse();
  InitDefaultsPeerStats();
  InitDefaultsRegionHeartbeatRequest();
  InitDefaultsChangePeer();
  InitDefaultsTransferLeader();
  InitDefaultsMerge();
  InitDefaultsSplitRegion();
  InitDefaultsRegionHeartbeatResponse();
  InitDefaultsAskSplitRequest();
  InitDefaultsAskSplitResponse();
  InitDefaultsReportSplitRequest();
  InitDefaultsReportSplitResponse();
  InitDefaultsAskBatchSplitRequest();
  InitDefaultsSplitID();
  InitDefaultsAskBatchSplitResponse();
  InitDefaultsReportBatchSplitRequest();
  InitDefaultsReportBatchSplitResponse();
  InitDefaultsTimeInterval();
  InitDefaultsStoreStats();
  InitDefaultsStoreHeartbeatRequest();
  InitDefaultsStoreHeartbeatResponse();
  InitDefaultsScatterRegionRequest();
  InitDefaultsScatterRegionResponse();
  InitDefaultsGetGCSafePointRequest();
  InitDefaultsGetGCSafePointResponse();
  InitDefaultsUpdateGCSafePointRequest();
  InitDefaultsUpdateGCSafePointResponse();
  InitDefaultsSyncRegionRequest();
  InitDefaultsSyncRegionResponse();
}
}  // namespace protobuf_pdpb_2eproto
namespace pdpb {
class AllocIDRequest;
class AllocIDRequestDefaultTypeInternal;
extern AllocIDRequestDefaultTypeInternal _AllocIDRequest_default_instance_;
class AllocIDResponse;
class AllocIDResponseDefaultTypeInternal;
extern AllocIDResponseDefaultTypeInternal _AllocIDResponse_default_instance_;
class AskBatchSplitRequest;
class AskBatchSplitRequestDefaultTypeInternal;
extern AskBatchSplitRequestDefaultTypeInternal _AskBatchSplitRequest_default_instance_;
class AskBatchSplitResponse;
class AskBatchSplitResponseDefaultTypeInternal;
extern AskBatchSplitResponseDefaultTypeInternal _AskBatchSplitResponse_default_instance_;
class AskSplitRequest;
class AskSplitRequestDefaultTypeInternal;
extern AskSplitRequestDefaultTypeInternal _AskSplitRequest_default_instance_;
class AskSplitResponse;
class AskSplitResponseDefaultTypeInternal;
extern AskSplitResponseDefaultTypeInternal _AskSplitResponse_default_instance_;
class BootstrapRequest;
class BootstrapRequestDefaultTypeInternal;
extern BootstrapRequestDefaultTypeInternal _BootstrapRequest_default_instance_;
class BootstrapResponse;
class BootstrapResponseDefaultTypeInternal;
extern BootstrapResponseDefaultTypeInternal _BootstrapResponse_default_instance_;
class ChangePeer;
class ChangePeerDefaultTypeInternal;
extern ChangePeerDefaultTypeInternal _ChangePeer_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class GetAllStoresRequest;
class GetAllStoresRequestDefaultTypeInternal;
extern GetAllStoresRequestDefaultTypeInternal _GetAllStoresRequest_default_instance_;
class GetAllStoresResponse;
class GetAllStoresResponseDefaultTypeInternal;
extern GetAllStoresResponseDefaultTypeInternal _GetAllStoresResponse_default_instance_;
class GetClusterConfigRequest;
class GetClusterConfigRequestDefaultTypeInternal;
extern GetClusterConfigRequestDefaultTypeInternal _GetClusterConfigRequest_default_instance_;
class GetClusterConfigResponse;
class GetClusterConfigResponseDefaultTypeInternal;
extern GetClusterConfigResponseDefaultTypeInternal _GetClusterConfigResponse_default_instance_;
class GetGCSafePointRequest;
class GetGCSafePointRequestDefaultTypeInternal;
extern GetGCSafePointRequestDefaultTypeInternal _GetGCSafePointRequest_default_instance_;
class GetGCSafePointResponse;
class GetGCSafePointResponseDefaultTypeInternal;
extern GetGCSafePointResponseDefaultTypeInternal _GetGCSafePointResponse_default_instance_;
class GetMembersRequest;
class GetMembersRequestDefaultTypeInternal;
extern GetMembersRequestDefaultTypeInternal _GetMembersRequest_default_instance_;
class GetMembersResponse;
class GetMembersResponseDefaultTypeInternal;
extern GetMembersResponseDefaultTypeInternal _GetMembersResponse_default_instance_;
class GetRegionByIDRequest;
class GetRegionByIDRequestDefaultTypeInternal;
extern GetRegionByIDRequestDefaultTypeInternal _GetRegionByIDRequest_default_instance_;
class GetRegionRequest;
class GetRegionRequestDefaultTypeInternal;
extern GetRegionRequestDefaultTypeInternal _GetRegionRequest_default_instance_;
class GetRegionResponse;
class GetRegionResponseDefaultTypeInternal;
extern GetRegionResponseDefaultTypeInternal _GetRegionResponse_default_instance_;
class GetStoreRequest;
class GetStoreRequestDefaultTypeInternal;
extern GetStoreRequestDefaultTypeInternal _GetStoreRequest_default_instance_;
class GetStoreResponse;
class GetStoreResponseDefaultTypeInternal;
extern GetStoreResponseDefaultTypeInternal _GetStoreResponse_default_instance_;
class IsBootstrappedRequest;
class IsBootstrappedRequestDefaultTypeInternal;
extern IsBootstrappedRequestDefaultTypeInternal _IsBootstrappedRequest_default_instance_;
class IsBootstrappedResponse;
class IsBootstrappedResponseDefaultTypeInternal;
extern IsBootstrappedResponseDefaultTypeInternal _IsBootstrappedResponse_default_instance_;
class Member;
class MemberDefaultTypeInternal;
extern MemberDefaultTypeInternal _Member_default_instance_;
class Merge;
class MergeDefaultTypeInternal;
extern MergeDefaultTypeInternal _Merge_default_instance_;
class PeerStats;
class PeerStatsDefaultTypeInternal;
extern PeerStatsDefaultTypeInternal _PeerStats_default_instance_;
class PutClusterConfigRequest;
class PutClusterConfigRequestDefaultTypeInternal;
extern PutClusterConfigRequestDefaultTypeInternal _PutClusterConfigRequest_default_instance_;
class PutClusterConfigResponse;
class PutClusterConfigResponseDefaultTypeInternal;
extern PutClusterConfigResponseDefaultTypeInternal _PutClusterConfigResponse_default_instance_;
class PutStoreRequest;
class PutStoreRequestDefaultTypeInternal;
extern PutStoreRequestDefaultTypeInternal _PutStoreRequest_default_instance_;
class PutStoreResponse;
class PutStoreResponseDefaultTypeInternal;
extern PutStoreResponseDefaultTypeInternal _PutStoreResponse_default_instance_;
class RegionHeartbeatRequest;
class RegionHeartbeatRequestDefaultTypeInternal;
extern RegionHeartbeatRequestDefaultTypeInternal _RegionHeartbeatRequest_default_instance_;
class RegionHeartbeatResponse;
class RegionHeartbeatResponseDefaultTypeInternal;
extern RegionHeartbeatResponseDefaultTypeInternal _RegionHeartbeatResponse_default_instance_;
class ReportBatchSplitRequest;
class ReportBatchSplitRequestDefaultTypeInternal;
extern ReportBatchSplitRequestDefaultTypeInternal _ReportBatchSplitRequest_default_instance_;
class ReportBatchSplitResponse;
class ReportBatchSplitResponseDefaultTypeInternal;
extern ReportBatchSplitResponseDefaultTypeInternal _ReportBatchSplitResponse_default_instance_;
class ReportSplitRequest;
class ReportSplitRequestDefaultTypeInternal;
extern ReportSplitRequestDefaultTypeInternal _ReportSplitRequest_default_instance_;
class ReportSplitResponse;
class ReportSplitResponseDefaultTypeInternal;
extern ReportSplitResponseDefaultTypeInternal _ReportSplitResponse_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class ScatterRegionRequest;
class ScatterRegionRequestDefaultTypeInternal;
extern ScatterRegionRequestDefaultTypeInternal _ScatterRegionRequest_default_instance_;
class ScatterRegionResponse;
class ScatterRegionResponseDefaultTypeInternal;
extern ScatterRegionResponseDefaultTypeInternal _ScatterRegionResponse_default_instance_;
class SplitID;
class SplitIDDefaultTypeInternal;
extern SplitIDDefaultTypeInternal _SplitID_default_instance_;
class SplitRegion;
class SplitRegionDefaultTypeInternal;
extern SplitRegionDefaultTypeInternal _SplitRegion_default_instance_;
class StoreHeartbeatRequest;
class StoreHeartbeatRequestDefaultTypeInternal;
extern StoreHeartbeatRequestDefaultTypeInternal _StoreHeartbeatRequest_default_instance_;
class StoreHeartbeatResponse;
class StoreHeartbeatResponseDefaultTypeInternal;
extern StoreHeartbeatResponseDefaultTypeInternal _StoreHeartbeatResponse_default_instance_;
class StoreStats;
class StoreStatsDefaultTypeInternal;
extern StoreStatsDefaultTypeInternal _StoreStats_default_instance_;
class SyncRegionRequest;
class SyncRegionRequestDefaultTypeInternal;
extern SyncRegionRequestDefaultTypeInternal _SyncRegionRequest_default_instance_;
class SyncRegionResponse;
class SyncRegionResponseDefaultTypeInternal;
extern SyncRegionResponseDefaultTypeInternal _SyncRegionResponse_default_instance_;
class TimeInterval;
class TimeIntervalDefaultTypeInternal;
extern TimeIntervalDefaultTypeInternal _TimeInterval_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TransferLeader;
class TransferLeaderDefaultTypeInternal;
extern TransferLeaderDefaultTypeInternal _TransferLeader_default_instance_;
class TsoRequest;
class TsoRequestDefaultTypeInternal;
extern TsoRequestDefaultTypeInternal _TsoRequest_default_instance_;
class TsoResponse;
class TsoResponseDefaultTypeInternal;
extern TsoResponseDefaultTypeInternal _TsoResponse_default_instance_;
class UpdateGCSafePointRequest;
class UpdateGCSafePointRequestDefaultTypeInternal;
extern UpdateGCSafePointRequestDefaultTypeInternal _UpdateGCSafePointRequest_default_instance_;
class UpdateGCSafePointResponse;
class UpdateGCSafePointResponseDefaultTypeInternal;
extern UpdateGCSafePointResponseDefaultTypeInternal _UpdateGCSafePointResponse_default_instance_;
}  // namespace pdpb
namespace pdpb {

enum ErrorType {
  OK = 0,
  UNKNOWN = 1,
  NOT_BOOTSTRAPPED = 2,
  STORE_TOMBSTONE = 3,
  ALREADY_BOOTSTRAPPED = 4,
  INCOMPATIBLE_VERSION = 5,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ErrorType_IsValid(int value);
const ErrorType ErrorType_MIN = OK;
const ErrorType ErrorType_MAX = INCOMPATIBLE_VERSION;
const int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorType_descriptor();
inline const ::std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorType_descriptor(), value);
}
inline bool ErrorType_Parse(
    const ::std::string& name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum CheckPolicy {
  SCAN = 0,
  APPROXIMATE = 1,
  CheckPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CheckPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CheckPolicy_IsValid(int value);
const CheckPolicy CheckPolicy_MIN = SCAN;
const CheckPolicy CheckPolicy_MAX = APPROXIMATE;
const int CheckPolicy_ARRAYSIZE = CheckPolicy_MAX + 1;

const ::google::protobuf::EnumDescriptor* CheckPolicy_descriptor();
inline const ::std::string& CheckPolicy_Name(CheckPolicy value) {
  return ::google::protobuf::internal::NameOfEnum(
    CheckPolicy_descriptor(), value);
}
inline bool CheckPolicy_Parse(
    const ::std::string& name, CheckPolicy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CheckPolicy>(
    CheckPolicy_descriptor(), name, value);
}
// ===================================================================

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 cluster_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsRequestHeaderImpl();
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::pdpb::Error& error() const;
  ::pdpb::Error* release_error();
  ::pdpb::Error* mutable_error();
  void set_allocated_error(::pdpb::Error* error);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::Error* error_;
  ::google::protobuf::uint64 cluster_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsResponseHeaderImpl();
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .pdpb.ErrorType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::pdpb::ErrorType type() const;
  void set_type(::pdpb::ErrorType value);

  // @@protoc_insertion_point(class_scope:pdpb.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsErrorImpl();
};
// -------------------------------------------------------------------

class TsoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.TsoRequest) */ {
 public:
  TsoRequest();
  virtual ~TsoRequest();

  TsoRequest(const TsoRequest& from);

  inline TsoRequest& operator=(const TsoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TsoRequest(TsoRequest&& from) noexcept
    : TsoRequest() {
    *this = ::std::move(from);
  }

  inline TsoRequest& operator=(TsoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TsoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TsoRequest* internal_default_instance() {
    return reinterpret_cast<const TsoRequest*>(
               &_TsoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TsoRequest* other);
  friend void swap(TsoRequest& a, TsoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TsoRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  TsoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TsoRequest& from);
  void MergeFrom(const TsoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TsoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // uint32 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pdpb.TsoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::google::protobuf::uint32 count_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsTsoRequestImpl();
};
// -------------------------------------------------------------------

class Timestamp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const PROTOBUF_FINAL { return New(NULL); }

  Timestamp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 physical = 1;
  void clear_physical();
  static const int kPhysicalFieldNumber = 1;
  ::google::protobuf::int64 physical() const;
  void set_physical(::google::protobuf::int64 value);

  // int64 logical = 2;
  void clear_logical();
  static const int kLogicalFieldNumber = 2;
  ::google::protobuf::int64 logical() const;
  void set_logical(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pdpb.Timestamp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 physical_;
  ::google::protobuf::int64 logical_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsTimestampImpl();
};
// -------------------------------------------------------------------

class TsoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.TsoResponse) */ {
 public:
  TsoResponse();
  virtual ~TsoResponse();

  TsoResponse(const TsoResponse& from);

  inline TsoResponse& operator=(const TsoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TsoResponse(TsoResponse&& from) noexcept
    : TsoResponse() {
    *this = ::std::move(from);
  }

  inline TsoResponse& operator=(TsoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TsoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TsoResponse* internal_default_instance() {
    return reinterpret_cast<const TsoResponse*>(
               &_TsoResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TsoResponse* other);
  friend void swap(TsoResponse& a, TsoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TsoResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  TsoResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TsoResponse& from);
  void MergeFrom(const TsoResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TsoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // .pdpb.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::pdpb::Timestamp& timestamp() const;
  ::pdpb::Timestamp* release_timestamp();
  ::pdpb::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::pdpb::Timestamp* timestamp);

  // uint32 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pdpb.TsoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  ::pdpb::Timestamp* timestamp_;
  ::google::protobuf::uint32 count_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsTsoResponseImpl();
};
// -------------------------------------------------------------------

class BootstrapRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.BootstrapRequest) */ {
 public:
  BootstrapRequest();
  virtual ~BootstrapRequest();

  BootstrapRequest(const BootstrapRequest& from);

  inline BootstrapRequest& operator=(const BootstrapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootstrapRequest(BootstrapRequest&& from) noexcept
    : BootstrapRequest() {
    *this = ::std::move(from);
  }

  inline BootstrapRequest& operator=(BootstrapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapRequest* internal_default_instance() {
    return reinterpret_cast<const BootstrapRequest*>(
               &_BootstrapRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(BootstrapRequest* other);
  friend void swap(BootstrapRequest& a, BootstrapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BootstrapRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BootstrapRequest& from);
  void MergeFrom(const BootstrapRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BootstrapRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .metapb.Store store = 2;
  bool has_store() const;
  void clear_store();
  static const int kStoreFieldNumber = 2;
  const ::metapb::Store& store() const;
  ::metapb::Store* release_store();
  ::metapb::Store* mutable_store();
  void set_allocated_store(::metapb::Store* store);

  // .metapb.Region region = 3;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 3;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // @@protoc_insertion_point(class_scope:pdpb.BootstrapRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::metapb::Store* store_;
  ::metapb::Region* region_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsBootstrapRequestImpl();
};
// -------------------------------------------------------------------

class BootstrapResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.BootstrapResponse) */ {
 public:
  BootstrapResponse();
  virtual ~BootstrapResponse();

  BootstrapResponse(const BootstrapResponse& from);

  inline BootstrapResponse& operator=(const BootstrapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootstrapResponse(BootstrapResponse&& from) noexcept
    : BootstrapResponse() {
    *this = ::std::move(from);
  }

  inline BootstrapResponse& operator=(BootstrapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapResponse* internal_default_instance() {
    return reinterpret_cast<const BootstrapResponse*>(
               &_BootstrapResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(BootstrapResponse* other);
  friend void swap(BootstrapResponse& a, BootstrapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BootstrapResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BootstrapResponse& from);
  void MergeFrom(const BootstrapResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BootstrapResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.BootstrapResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsBootstrapResponseImpl();
};
// -------------------------------------------------------------------

class IsBootstrappedRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.IsBootstrappedRequest) */ {
 public:
  IsBootstrappedRequest();
  virtual ~IsBootstrappedRequest();

  IsBootstrappedRequest(const IsBootstrappedRequest& from);

  inline IsBootstrappedRequest& operator=(const IsBootstrappedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsBootstrappedRequest(IsBootstrappedRequest&& from) noexcept
    : IsBootstrappedRequest() {
    *this = ::std::move(from);
  }

  inline IsBootstrappedRequest& operator=(IsBootstrappedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsBootstrappedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsBootstrappedRequest* internal_default_instance() {
    return reinterpret_cast<const IsBootstrappedRequest*>(
               &_IsBootstrappedRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(IsBootstrappedRequest* other);
  friend void swap(IsBootstrappedRequest& a, IsBootstrappedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsBootstrappedRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  IsBootstrappedRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IsBootstrappedRequest& from);
  void MergeFrom(const IsBootstrappedRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IsBootstrappedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.IsBootstrappedRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsIsBootstrappedRequestImpl();
};
// -------------------------------------------------------------------

class IsBootstrappedResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.IsBootstrappedResponse) */ {
 public:
  IsBootstrappedResponse();
  virtual ~IsBootstrappedResponse();

  IsBootstrappedResponse(const IsBootstrappedResponse& from);

  inline IsBootstrappedResponse& operator=(const IsBootstrappedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsBootstrappedResponse(IsBootstrappedResponse&& from) noexcept
    : IsBootstrappedResponse() {
    *this = ::std::move(from);
  }

  inline IsBootstrappedResponse& operator=(IsBootstrappedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsBootstrappedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsBootstrappedResponse* internal_default_instance() {
    return reinterpret_cast<const IsBootstrappedResponse*>(
               &_IsBootstrappedResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(IsBootstrappedResponse* other);
  friend void swap(IsBootstrappedResponse& a, IsBootstrappedResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsBootstrappedResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  IsBootstrappedResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IsBootstrappedResponse& from);
  void MergeFrom(const IsBootstrappedResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IsBootstrappedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // bool bootstrapped = 2;
  void clear_bootstrapped();
  static const int kBootstrappedFieldNumber = 2;
  bool bootstrapped() const;
  void set_bootstrapped(bool value);

  // @@protoc_insertion_point(class_scope:pdpb.IsBootstrappedResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  bool bootstrapped_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsIsBootstrappedResponseImpl();
};
// -------------------------------------------------------------------

class AllocIDRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.AllocIDRequest) */ {
 public:
  AllocIDRequest();
  virtual ~AllocIDRequest();

  AllocIDRequest(const AllocIDRequest& from);

  inline AllocIDRequest& operator=(const AllocIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllocIDRequest(AllocIDRequest&& from) noexcept
    : AllocIDRequest() {
    *this = ::std::move(from);
  }

  inline AllocIDRequest& operator=(AllocIDRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocIDRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocIDRequest* internal_default_instance() {
    return reinterpret_cast<const AllocIDRequest*>(
               &_AllocIDRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(AllocIDRequest* other);
  friend void swap(AllocIDRequest& a, AllocIDRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllocIDRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AllocIDRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AllocIDRequest& from);
  void MergeFrom(const AllocIDRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AllocIDRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.AllocIDRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsAllocIDRequestImpl();
};
// -------------------------------------------------------------------

class AllocIDResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.AllocIDResponse) */ {
 public:
  AllocIDResponse();
  virtual ~AllocIDResponse();

  AllocIDResponse(const AllocIDResponse& from);

  inline AllocIDResponse& operator=(const AllocIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllocIDResponse(AllocIDResponse&& from) noexcept
    : AllocIDResponse() {
    *this = ::std::move(from);
  }

  inline AllocIDResponse& operator=(AllocIDResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocIDResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocIDResponse* internal_default_instance() {
    return reinterpret_cast<const AllocIDResponse*>(
               &_AllocIDResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(AllocIDResponse* other);
  friend void swap(AllocIDResponse& a, AllocIDResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllocIDResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AllocIDResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AllocIDResponse& from);
  void MergeFrom(const AllocIDResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AllocIDResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // uint64 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.AllocIDResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  ::google::protobuf::uint64 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsAllocIDResponseImpl();
};
// -------------------------------------------------------------------

class GetStoreRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetStoreRequest) */ {
 public:
  GetStoreRequest();
  virtual ~GetStoreRequest();

  GetStoreRequest(const GetStoreRequest& from);

  inline GetStoreRequest& operator=(const GetStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetStoreRequest(GetStoreRequest&& from) noexcept
    : GetStoreRequest() {
    *this = ::std::move(from);
  }

  inline GetStoreRequest& operator=(GetStoreRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStoreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStoreRequest* internal_default_instance() {
    return reinterpret_cast<const GetStoreRequest*>(
               &_GetStoreRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(GetStoreRequest* other);
  friend void swap(GetStoreRequest& a, GetStoreRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetStoreRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetStoreRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetStoreRequest& from);
  void MergeFrom(const GetStoreRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetStoreRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // uint64 store_id = 2;
  void clear_store_id();
  static const int kStoreIdFieldNumber = 2;
  ::google::protobuf::uint64 store_id() const;
  void set_store_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.GetStoreRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::google::protobuf::uint64 store_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetStoreRequestImpl();
};
// -------------------------------------------------------------------

class GetStoreResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetStoreResponse) */ {
 public:
  GetStoreResponse();
  virtual ~GetStoreResponse();

  GetStoreResponse(const GetStoreResponse& from);

  inline GetStoreResponse& operator=(const GetStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetStoreResponse(GetStoreResponse&& from) noexcept
    : GetStoreResponse() {
    *this = ::std::move(from);
  }

  inline GetStoreResponse& operator=(GetStoreResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStoreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStoreResponse* internal_default_instance() {
    return reinterpret_cast<const GetStoreResponse*>(
               &_GetStoreResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(GetStoreResponse* other);
  friend void swap(GetStoreResponse& a, GetStoreResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetStoreResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetStoreResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetStoreResponse& from);
  void MergeFrom(const GetStoreResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetStoreResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // .metapb.Store store = 2;
  bool has_store() const;
  void clear_store();
  static const int kStoreFieldNumber = 2;
  const ::metapb::Store& store() const;
  ::metapb::Store* release_store();
  ::metapb::Store* mutable_store();
  void set_allocated_store(::metapb::Store* store);

  // @@protoc_insertion_point(class_scope:pdpb.GetStoreResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  ::metapb::Store* store_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetStoreResponseImpl();
};
// -------------------------------------------------------------------

class PutStoreRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.PutStoreRequest) */ {
 public:
  PutStoreRequest();
  virtual ~PutStoreRequest();

  PutStoreRequest(const PutStoreRequest& from);

  inline PutStoreRequest& operator=(const PutStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutStoreRequest(PutStoreRequest&& from) noexcept
    : PutStoreRequest() {
    *this = ::std::move(from);
  }

  inline PutStoreRequest& operator=(PutStoreRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PutStoreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutStoreRequest* internal_default_instance() {
    return reinterpret_cast<const PutStoreRequest*>(
               &_PutStoreRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(PutStoreRequest* other);
  friend void swap(PutStoreRequest& a, PutStoreRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutStoreRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PutStoreRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PutStoreRequest& from);
  void MergeFrom(const PutStoreRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PutStoreRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .metapb.Store store = 2;
  bool has_store() const;
  void clear_store();
  static const int kStoreFieldNumber = 2;
  const ::metapb::Store& store() const;
  ::metapb::Store* release_store();
  ::metapb::Store* mutable_store();
  void set_allocated_store(::metapb::Store* store);

  // @@protoc_insertion_point(class_scope:pdpb.PutStoreRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::metapb::Store* store_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsPutStoreRequestImpl();
};
// -------------------------------------------------------------------

class PutStoreResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.PutStoreResponse) */ {
 public:
  PutStoreResponse();
  virtual ~PutStoreResponse();

  PutStoreResponse(const PutStoreResponse& from);

  inline PutStoreResponse& operator=(const PutStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutStoreResponse(PutStoreResponse&& from) noexcept
    : PutStoreResponse() {
    *this = ::std::move(from);
  }

  inline PutStoreResponse& operator=(PutStoreResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PutStoreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutStoreResponse* internal_default_instance() {
    return reinterpret_cast<const PutStoreResponse*>(
               &_PutStoreResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(PutStoreResponse* other);
  friend void swap(PutStoreResponse& a, PutStoreResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutStoreResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PutStoreResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PutStoreResponse& from);
  void MergeFrom(const PutStoreResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PutStoreResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.PutStoreResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsPutStoreResponseImpl();
};
// -------------------------------------------------------------------

class GetAllStoresRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetAllStoresRequest) */ {
 public:
  GetAllStoresRequest();
  virtual ~GetAllStoresRequest();

  GetAllStoresRequest(const GetAllStoresRequest& from);

  inline GetAllStoresRequest& operator=(const GetAllStoresRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAllStoresRequest(GetAllStoresRequest&& from) noexcept
    : GetAllStoresRequest() {
    *this = ::std::move(from);
  }

  inline GetAllStoresRequest& operator=(GetAllStoresRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllStoresRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllStoresRequest* internal_default_instance() {
    return reinterpret_cast<const GetAllStoresRequest*>(
               &_GetAllStoresRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(GetAllStoresRequest* other);
  friend void swap(GetAllStoresRequest& a, GetAllStoresRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAllStoresRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAllStoresRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAllStoresRequest& from);
  void MergeFrom(const GetAllStoresRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAllStoresRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.GetAllStoresRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetAllStoresRequestImpl();
};
// -------------------------------------------------------------------

class GetAllStoresResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetAllStoresResponse) */ {
 public:
  GetAllStoresResponse();
  virtual ~GetAllStoresResponse();

  GetAllStoresResponse(const GetAllStoresResponse& from);

  inline GetAllStoresResponse& operator=(const GetAllStoresResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAllStoresResponse(GetAllStoresResponse&& from) noexcept
    : GetAllStoresResponse() {
    *this = ::std::move(from);
  }

  inline GetAllStoresResponse& operator=(GetAllStoresResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllStoresResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllStoresResponse* internal_default_instance() {
    return reinterpret_cast<const GetAllStoresResponse*>(
               &_GetAllStoresResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(GetAllStoresResponse* other);
  friend void swap(GetAllStoresResponse& a, GetAllStoresResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAllStoresResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAllStoresResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAllStoresResponse& from);
  void MergeFrom(const GetAllStoresResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAllStoresResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Store stores = 2;
  int stores_size() const;
  void clear_stores();
  static const int kStoresFieldNumber = 2;
  const ::metapb::Store& stores(int index) const;
  ::metapb::Store* mutable_stores(int index);
  ::metapb::Store* add_stores();
  ::google::protobuf::RepeatedPtrField< ::metapb::Store >*
      mutable_stores();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Store >&
      stores() const;

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.GetAllStoresResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Store > stores_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetAllStoresResponseImpl();
};
// -------------------------------------------------------------------

class GetRegionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetRegionRequest) */ {
 public:
  GetRegionRequest();
  virtual ~GetRegionRequest();

  GetRegionRequest(const GetRegionRequest& from);

  inline GetRegionRequest& operator=(const GetRegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRegionRequest(GetRegionRequest&& from) noexcept
    : GetRegionRequest() {
    *this = ::std::move(from);
  }

  inline GetRegionRequest& operator=(GetRegionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRegionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRegionRequest* internal_default_instance() {
    return reinterpret_cast<const GetRegionRequest*>(
               &_GetRegionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(GetRegionRequest* other);
  friend void swap(GetRegionRequest& a, GetRegionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRegionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRegionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRegionRequest& from);
  void MergeFrom(const GetRegionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRegionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes region_key = 2;
  void clear_region_key();
  static const int kRegionKeyFieldNumber = 2;
  const ::std::string& region_key() const;
  void set_region_key(const ::std::string& value);
  #if LANG_CXX11
  void set_region_key(::std::string&& value);
  #endif
  void set_region_key(const char* value);
  void set_region_key(const void* value, size_t size);
  ::std::string* mutable_region_key();
  ::std::string* release_region_key();
  void set_allocated_region_key(::std::string* region_key);

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.GetRegionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr region_key_;
  ::pdpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetRegionRequestImpl();
};
// -------------------------------------------------------------------

class GetRegionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetRegionResponse) */ {
 public:
  GetRegionResponse();
  virtual ~GetRegionResponse();

  GetRegionResponse(const GetRegionResponse& from);

  inline GetRegionResponse& operator=(const GetRegionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRegionResponse(GetRegionResponse&& from) noexcept
    : GetRegionResponse() {
    *this = ::std::move(from);
  }

  inline GetRegionResponse& operator=(GetRegionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRegionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRegionResponse* internal_default_instance() {
    return reinterpret_cast<const GetRegionResponse*>(
               &_GetRegionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(GetRegionResponse* other);
  friend void swap(GetRegionResponse& a, GetRegionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRegionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRegionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRegionResponse& from);
  void MergeFrom(const GetRegionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRegionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // .metapb.Region region = 2;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 2;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // .metapb.Peer leader = 3;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 3;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* release_leader();
  ::metapb::Peer* mutable_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // @@protoc_insertion_point(class_scope:pdpb.GetRegionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  ::metapb::Region* region_;
  ::metapb::Peer* leader_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetRegionResponseImpl();
};
// -------------------------------------------------------------------

class GetRegionByIDRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetRegionByIDRequest) */ {
 public:
  GetRegionByIDRequest();
  virtual ~GetRegionByIDRequest();

  GetRegionByIDRequest(const GetRegionByIDRequest& from);

  inline GetRegionByIDRequest& operator=(const GetRegionByIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRegionByIDRequest(GetRegionByIDRequest&& from) noexcept
    : GetRegionByIDRequest() {
    *this = ::std::move(from);
  }

  inline GetRegionByIDRequest& operator=(GetRegionByIDRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRegionByIDRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRegionByIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetRegionByIDRequest*>(
               &_GetRegionByIDRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(GetRegionByIDRequest* other);
  friend void swap(GetRegionByIDRequest& a, GetRegionByIDRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRegionByIDRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRegionByIDRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRegionByIDRequest& from);
  void MergeFrom(const GetRegionByIDRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRegionByIDRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // uint64 region_id = 2;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 2;
  ::google::protobuf::uint64 region_id() const;
  void set_region_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.GetRegionByIDRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::google::protobuf::uint64 region_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetRegionByIDRequestImpl();
};
// -------------------------------------------------------------------

class GetClusterConfigRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetClusterConfigRequest) */ {
 public:
  GetClusterConfigRequest();
  virtual ~GetClusterConfigRequest();

  GetClusterConfigRequest(const GetClusterConfigRequest& from);

  inline GetClusterConfigRequest& operator=(const GetClusterConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetClusterConfigRequest(GetClusterConfigRequest&& from) noexcept
    : GetClusterConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetClusterConfigRequest& operator=(GetClusterConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetClusterConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetClusterConfigRequest*>(
               &_GetClusterConfigRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(GetClusterConfigRequest* other);
  friend void swap(GetClusterConfigRequest& a, GetClusterConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetClusterConfigRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetClusterConfigRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetClusterConfigRequest& from);
  void MergeFrom(const GetClusterConfigRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetClusterConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.GetClusterConfigRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetClusterConfigRequestImpl();
};
// -------------------------------------------------------------------

class GetClusterConfigResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetClusterConfigResponse) */ {
 public:
  GetClusterConfigResponse();
  virtual ~GetClusterConfigResponse();

  GetClusterConfigResponse(const GetClusterConfigResponse& from);

  inline GetClusterConfigResponse& operator=(const GetClusterConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetClusterConfigResponse(GetClusterConfigResponse&& from) noexcept
    : GetClusterConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetClusterConfigResponse& operator=(GetClusterConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetClusterConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetClusterConfigResponse*>(
               &_GetClusterConfigResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(GetClusterConfigResponse* other);
  friend void swap(GetClusterConfigResponse& a, GetClusterConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetClusterConfigResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetClusterConfigResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetClusterConfigResponse& from);
  void MergeFrom(const GetClusterConfigResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetClusterConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // .metapb.Cluster cluster = 2;
  bool has_cluster() const;
  void clear_cluster();
  static const int kClusterFieldNumber = 2;
  const ::metapb::Cluster& cluster() const;
  ::metapb::Cluster* release_cluster();
  ::metapb::Cluster* mutable_cluster();
  void set_allocated_cluster(::metapb::Cluster* cluster);

  // @@protoc_insertion_point(class_scope:pdpb.GetClusterConfigResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  ::metapb::Cluster* cluster_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetClusterConfigResponseImpl();
};
// -------------------------------------------------------------------

class PutClusterConfigRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.PutClusterConfigRequest) */ {
 public:
  PutClusterConfigRequest();
  virtual ~PutClusterConfigRequest();

  PutClusterConfigRequest(const PutClusterConfigRequest& from);

  inline PutClusterConfigRequest& operator=(const PutClusterConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutClusterConfigRequest(PutClusterConfigRequest&& from) noexcept
    : PutClusterConfigRequest() {
    *this = ::std::move(from);
  }

  inline PutClusterConfigRequest& operator=(PutClusterConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PutClusterConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutClusterConfigRequest* internal_default_instance() {
    return reinterpret_cast<const PutClusterConfigRequest*>(
               &_PutClusterConfigRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(PutClusterConfigRequest* other);
  friend void swap(PutClusterConfigRequest& a, PutClusterConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutClusterConfigRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PutClusterConfigRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PutClusterConfigRequest& from);
  void MergeFrom(const PutClusterConfigRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PutClusterConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .metapb.Cluster cluster = 2;
  bool has_cluster() const;
  void clear_cluster();
  static const int kClusterFieldNumber = 2;
  const ::metapb::Cluster& cluster() const;
  ::metapb::Cluster* release_cluster();
  ::metapb::Cluster* mutable_cluster();
  void set_allocated_cluster(::metapb::Cluster* cluster);

  // @@protoc_insertion_point(class_scope:pdpb.PutClusterConfigRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::metapb::Cluster* cluster_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsPutClusterConfigRequestImpl();
};
// -------------------------------------------------------------------

class PutClusterConfigResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.PutClusterConfigResponse) */ {
 public:
  PutClusterConfigResponse();
  virtual ~PutClusterConfigResponse();

  PutClusterConfigResponse(const PutClusterConfigResponse& from);

  inline PutClusterConfigResponse& operator=(const PutClusterConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutClusterConfigResponse(PutClusterConfigResponse&& from) noexcept
    : PutClusterConfigResponse() {
    *this = ::std::move(from);
  }

  inline PutClusterConfigResponse& operator=(PutClusterConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PutClusterConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutClusterConfigResponse* internal_default_instance() {
    return reinterpret_cast<const PutClusterConfigResponse*>(
               &_PutClusterConfigResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(PutClusterConfigResponse* other);
  friend void swap(PutClusterConfigResponse& a, PutClusterConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutClusterConfigResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PutClusterConfigResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PutClusterConfigResponse& from);
  void MergeFrom(const PutClusterConfigResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PutClusterConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.PutClusterConfigResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsPutClusterConfigResponseImpl();
};
// -------------------------------------------------------------------

class Member : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.Member) */ {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Member(Member&& from) noexcept
    : Member() {
    *this = ::std::move(from);
  }

  inline Member& operator=(Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Member* internal_default_instance() {
    return reinterpret_cast<const Member*>(
               &_Member_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(Member* other);
  friend void swap(Member& a, Member& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Member* New() const PROTOBUF_FINAL { return New(NULL); }

  Member* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Member* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string peer_urls = 3;
  int peer_urls_size() const;
  void clear_peer_urls();
  static const int kPeerUrlsFieldNumber = 3;
  const ::std::string& peer_urls(int index) const;
  ::std::string* mutable_peer_urls(int index);
  void set_peer_urls(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_peer_urls(int index, ::std::string&& value);
  #endif
  void set_peer_urls(int index, const char* value);
  void set_peer_urls(int index, const char* value, size_t size);
  ::std::string* add_peer_urls();
  void add_peer_urls(const ::std::string& value);
  #if LANG_CXX11
  void add_peer_urls(::std::string&& value);
  #endif
  void add_peer_urls(const char* value);
  void add_peer_urls(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& peer_urls() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_peer_urls();

  // repeated string client_urls = 4;
  int client_urls_size() const;
  void clear_client_urls();
  static const int kClientUrlsFieldNumber = 4;
  const ::std::string& client_urls(int index) const;
  ::std::string* mutable_client_urls(int index);
  void set_client_urls(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_client_urls(int index, ::std::string&& value);
  #endif
  void set_client_urls(int index, const char* value);
  void set_client_urls(int index, const char* value, size_t size);
  ::std::string* add_client_urls();
  void add_client_urls(const ::std::string& value);
  #if LANG_CXX11
  void add_client_urls(::std::string&& value);
  #endif
  void add_client_urls(const char* value);
  void add_client_urls(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& client_urls() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_client_urls();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint64 member_id = 2;
  void clear_member_id();
  static const int kMemberIdFieldNumber = 2;
  ::google::protobuf::uint64 member_id() const;
  void set_member_id(::google::protobuf::uint64 value);

  // int32 leader_priority = 5;
  void clear_leader_priority();
  static const int kLeaderPriorityFieldNumber = 5;
  ::google::protobuf::int32 leader_priority() const;
  void set_leader_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pdpb.Member)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> peer_urls_;
  ::google::protobuf::RepeatedPtrField< ::std::string> client_urls_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 member_id_;
  ::google::protobuf::int32 leader_priority_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsMemberImpl();
};
// -------------------------------------------------------------------

class GetMembersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetMembersRequest) */ {
 public:
  GetMembersRequest();
  virtual ~GetMembersRequest();

  GetMembersRequest(const GetMembersRequest& from);

  inline GetMembersRequest& operator=(const GetMembersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMembersRequest(GetMembersRequest&& from) noexcept
    : GetMembersRequest() {
    *this = ::std::move(from);
  }

  inline GetMembersRequest& operator=(GetMembersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMembersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMembersRequest* internal_default_instance() {
    return reinterpret_cast<const GetMembersRequest*>(
               &_GetMembersRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(GetMembersRequest* other);
  friend void swap(GetMembersRequest& a, GetMembersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMembersRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetMembersRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetMembersRequest& from);
  void MergeFrom(const GetMembersRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetMembersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.GetMembersRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetMembersRequestImpl();
};
// -------------------------------------------------------------------

class GetMembersResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetMembersResponse) */ {
 public:
  GetMembersResponse();
  virtual ~GetMembersResponse();

  GetMembersResponse(const GetMembersResponse& from);

  inline GetMembersResponse& operator=(const GetMembersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMembersResponse(GetMembersResponse&& from) noexcept
    : GetMembersResponse() {
    *this = ::std::move(from);
  }

  inline GetMembersResponse& operator=(GetMembersResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMembersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMembersResponse* internal_default_instance() {
    return reinterpret_cast<const GetMembersResponse*>(
               &_GetMembersResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(GetMembersResponse* other);
  friend void swap(GetMembersResponse& a, GetMembersResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMembersResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetMembersResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetMembersResponse& from);
  void MergeFrom(const GetMembersResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetMembersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pdpb.Member members = 2;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 2;
  const ::pdpb::Member& members(int index) const;
  ::pdpb::Member* mutable_members(int index);
  ::pdpb::Member* add_members();
  ::google::protobuf::RepeatedPtrField< ::pdpb::Member >*
      mutable_members();
  const ::google::protobuf::RepeatedPtrField< ::pdpb::Member >&
      members() const;

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // .pdpb.Member leader = 3;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 3;
  const ::pdpb::Member& leader() const;
  ::pdpb::Member* release_leader();
  ::pdpb::Member* mutable_leader();
  void set_allocated_leader(::pdpb::Member* leader);

  // .pdpb.Member etcd_leader = 4;
  bool has_etcd_leader() const;
  void clear_etcd_leader();
  static const int kEtcdLeaderFieldNumber = 4;
  const ::pdpb::Member& etcd_leader() const;
  ::pdpb::Member* release_etcd_leader();
  ::pdpb::Member* mutable_etcd_leader();
  void set_allocated_etcd_leader(::pdpb::Member* etcd_leader);

  // @@protoc_insertion_point(class_scope:pdpb.GetMembersResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pdpb::Member > members_;
  ::pdpb::ResponseHeader* header_;
  ::pdpb::Member* leader_;
  ::pdpb::Member* etcd_leader_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetMembersResponseImpl();
};
// -------------------------------------------------------------------

class PeerStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.PeerStats) */ {
 public:
  PeerStats();
  virtual ~PeerStats();

  PeerStats(const PeerStats& from);

  inline PeerStats& operator=(const PeerStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerStats(PeerStats&& from) noexcept
    : PeerStats() {
    *this = ::std::move(from);
  }

  inline PeerStats& operator=(PeerStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerStats* internal_default_instance() {
    return reinterpret_cast<const PeerStats*>(
               &_PeerStats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(PeerStats* other);
  friend void swap(PeerStats& a, PeerStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerStats* New() const PROTOBUF_FINAL { return New(NULL); }

  PeerStats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PeerStats& from);
  void MergeFrom(const PeerStats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PeerStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::metapb::Peer& peer() const;
  ::metapb::Peer* release_peer();
  ::metapb::Peer* mutable_peer();
  void set_allocated_peer(::metapb::Peer* peer);

  // uint64 down_seconds = 2;
  void clear_down_seconds();
  static const int kDownSecondsFieldNumber = 2;
  ::google::protobuf::uint64 down_seconds() const;
  void set_down_seconds(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.PeerStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Peer* peer_;
  ::google::protobuf::uint64 down_seconds_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsPeerStatsImpl();
};
// -------------------------------------------------------------------

class RegionHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.RegionHeartbeatRequest) */ {
 public:
  RegionHeartbeatRequest();
  virtual ~RegionHeartbeatRequest();

  RegionHeartbeatRequest(const RegionHeartbeatRequest& from);

  inline RegionHeartbeatRequest& operator=(const RegionHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionHeartbeatRequest(RegionHeartbeatRequest&& from) noexcept
    : RegionHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline RegionHeartbeatRequest& operator=(RegionHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionHeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const RegionHeartbeatRequest*>(
               &_RegionHeartbeatRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(RegionHeartbeatRequest* other);
  friend void swap(RegionHeartbeatRequest& a, RegionHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionHeartbeatRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RegionHeartbeatRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegionHeartbeatRequest& from);
  void MergeFrom(const RegionHeartbeatRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegionHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pdpb.PeerStats down_peers = 4;
  int down_peers_size() const;
  void clear_down_peers();
  static const int kDownPeersFieldNumber = 4;
  const ::pdpb::PeerStats& down_peers(int index) const;
  ::pdpb::PeerStats* mutable_down_peers(int index);
  ::pdpb::PeerStats* add_down_peers();
  ::google::protobuf::RepeatedPtrField< ::pdpb::PeerStats >*
      mutable_down_peers();
  const ::google::protobuf::RepeatedPtrField< ::pdpb::PeerStats >&
      down_peers() const;

  // repeated .metapb.Peer pending_peers = 5;
  int pending_peers_size() const;
  void clear_pending_peers();
  static const int kPendingPeersFieldNumber = 5;
  const ::metapb::Peer& pending_peers(int index) const;
  ::metapb::Peer* mutable_pending_peers(int index);
  ::metapb::Peer* add_pending_peers();
  ::google::protobuf::RepeatedPtrField< ::metapb::Peer >*
      mutable_pending_peers();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Peer >&
      pending_peers() const;

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .metapb.Region region = 2;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 2;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // .metapb.Peer leader = 3;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 3;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* release_leader();
  ::metapb::Peer* mutable_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // .pdpb.TimeInterval interval = 12;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 12;
  const ::pdpb::TimeInterval& interval() const;
  ::pdpb::TimeInterval* release_interval();
  ::pdpb::TimeInterval* mutable_interval();
  void set_allocated_interval(::pdpb::TimeInterval* interval);

  // uint64 bytes_written = 6;
  void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 6;
  ::google::protobuf::uint64 bytes_written() const;
  void set_bytes_written(::google::protobuf::uint64 value);

  // uint64 bytes_read = 7;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 7;
  ::google::protobuf::uint64 bytes_read() const;
  void set_bytes_read(::google::protobuf::uint64 value);

  // uint64 keys_written = 8;
  void clear_keys_written();
  static const int kKeysWrittenFieldNumber = 8;
  ::google::protobuf::uint64 keys_written() const;
  void set_keys_written(::google::protobuf::uint64 value);

  // uint64 keys_read = 9;
  void clear_keys_read();
  static const int kKeysReadFieldNumber = 9;
  ::google::protobuf::uint64 keys_read() const;
  void set_keys_read(::google::protobuf::uint64 value);

  // uint64 approximate_size = 10;
  void clear_approximate_size();
  static const int kApproximateSizeFieldNumber = 10;
  ::google::protobuf::uint64 approximate_size() const;
  void set_approximate_size(::google::protobuf::uint64 value);

  // uint64 approximate_keys = 13;
  void clear_approximate_keys();
  static const int kApproximateKeysFieldNumber = 13;
  ::google::protobuf::uint64 approximate_keys() const;
  void set_approximate_keys(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.RegionHeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pdpb::PeerStats > down_peers_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Peer > pending_peers_;
  ::pdpb::RequestHeader* header_;
  ::metapb::Region* region_;
  ::metapb::Peer* leader_;
  ::pdpb::TimeInterval* interval_;
  ::google::protobuf::uint64 bytes_written_;
  ::google::protobuf::uint64 bytes_read_;
  ::google::protobuf::uint64 keys_written_;
  ::google::protobuf::uint64 keys_read_;
  ::google::protobuf::uint64 approximate_size_;
  ::google::protobuf::uint64 approximate_keys_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsRegionHeartbeatRequestImpl();
};
// -------------------------------------------------------------------

class ChangePeer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.ChangePeer) */ {
 public:
  ChangePeer();
  virtual ~ChangePeer();

  ChangePeer(const ChangePeer& from);

  inline ChangePeer& operator=(const ChangePeer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangePeer(ChangePeer&& from) noexcept
    : ChangePeer() {
    *this = ::std::move(from);
  }

  inline ChangePeer& operator=(ChangePeer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePeer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangePeer* internal_default_instance() {
    return reinterpret_cast<const ChangePeer*>(
               &_ChangePeer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(ChangePeer* other);
  friend void swap(ChangePeer& a, ChangePeer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangePeer* New() const PROTOBUF_FINAL { return New(NULL); }

  ChangePeer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChangePeer& from);
  void MergeFrom(const ChangePeer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChangePeer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::metapb::Peer& peer() const;
  ::metapb::Peer* release_peer();
  ::metapb::Peer* mutable_peer();
  void set_allocated_peer(::metapb::Peer* peer);

  // .eraftpb.ConfChangeType change_type = 2;
  void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  ::eraftpb::ConfChangeType change_type() const;
  void set_change_type(::eraftpb::ConfChangeType value);

  // @@protoc_insertion_point(class_scope:pdpb.ChangePeer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Peer* peer_;
  int change_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsChangePeerImpl();
};
// -------------------------------------------------------------------

class TransferLeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.TransferLeader) */ {
 public:
  TransferLeader();
  virtual ~TransferLeader();

  TransferLeader(const TransferLeader& from);

  inline TransferLeader& operator=(const TransferLeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferLeader(TransferLeader&& from) noexcept
    : TransferLeader() {
    *this = ::std::move(from);
  }

  inline TransferLeader& operator=(TransferLeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferLeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferLeader* internal_default_instance() {
    return reinterpret_cast<const TransferLeader*>(
               &_TransferLeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(TransferLeader* other);
  friend void swap(TransferLeader& a, TransferLeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferLeader* New() const PROTOBUF_FINAL { return New(NULL); }

  TransferLeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransferLeader& from);
  void MergeFrom(const TransferLeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransferLeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::metapb::Peer& peer() const;
  ::metapb::Peer* release_peer();
  ::metapb::Peer* mutable_peer();
  void set_allocated_peer(::metapb::Peer* peer);

  // @@protoc_insertion_point(class_scope:pdpb.TransferLeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Peer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsTransferLeaderImpl();
};
// -------------------------------------------------------------------

class Merge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.Merge) */ {
 public:
  Merge();
  virtual ~Merge();

  Merge(const Merge& from);

  inline Merge& operator=(const Merge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Merge(Merge&& from) noexcept
    : Merge() {
    *this = ::std::move(from);
  }

  inline Merge& operator=(Merge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Merge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Merge* internal_default_instance() {
    return reinterpret_cast<const Merge*>(
               &_Merge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(Merge* other);
  friend void swap(Merge& a, Merge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Merge* New() const PROTOBUF_FINAL { return New(NULL); }

  Merge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Merge& from);
  void MergeFrom(const Merge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Merge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Region target = 1;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::metapb::Region& target() const;
  ::metapb::Region* release_target();
  ::metapb::Region* mutable_target();
  void set_allocated_target(::metapb::Region* target);

  // @@protoc_insertion_point(class_scope:pdpb.Merge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Region* target_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsMergeImpl();
};
// -------------------------------------------------------------------

class SplitRegion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.SplitRegion) */ {
 public:
  SplitRegion();
  virtual ~SplitRegion();

  SplitRegion(const SplitRegion& from);

  inline SplitRegion& operator=(const SplitRegion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplitRegion(SplitRegion&& from) noexcept
    : SplitRegion() {
    *this = ::std::move(from);
  }

  inline SplitRegion& operator=(SplitRegion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitRegion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitRegion* internal_default_instance() {
    return reinterpret_cast<const SplitRegion*>(
               &_SplitRegion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(SplitRegion* other);
  friend void swap(SplitRegion& a, SplitRegion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitRegion* New() const PROTOBUF_FINAL { return New(NULL); }

  SplitRegion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SplitRegion& from);
  void MergeFrom(const SplitRegion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SplitRegion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.CheckPolicy policy = 1;
  void clear_policy();
  static const int kPolicyFieldNumber = 1;
  ::pdpb::CheckPolicy policy() const;
  void set_policy(::pdpb::CheckPolicy value);

  // @@protoc_insertion_point(class_scope:pdpb.SplitRegion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int policy_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsSplitRegionImpl();
};
// -------------------------------------------------------------------

class RegionHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.RegionHeartbeatResponse) */ {
 public:
  RegionHeartbeatResponse();
  virtual ~RegionHeartbeatResponse();

  RegionHeartbeatResponse(const RegionHeartbeatResponse& from);

  inline RegionHeartbeatResponse& operator=(const RegionHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionHeartbeatResponse(RegionHeartbeatResponse&& from) noexcept
    : RegionHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline RegionHeartbeatResponse& operator=(RegionHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionHeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const RegionHeartbeatResponse*>(
               &_RegionHeartbeatResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(RegionHeartbeatResponse* other);
  friend void swap(RegionHeartbeatResponse& a, RegionHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionHeartbeatResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RegionHeartbeatResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegionHeartbeatResponse& from);
  void MergeFrom(const RegionHeartbeatResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegionHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // .pdpb.ChangePeer change_peer = 2;
  bool has_change_peer() const;
  void clear_change_peer();
  static const int kChangePeerFieldNumber = 2;
  const ::pdpb::ChangePeer& change_peer() const;
  ::pdpb::ChangePeer* release_change_peer();
  ::pdpb::ChangePeer* mutable_change_peer();
  void set_allocated_change_peer(::pdpb::ChangePeer* change_peer);

  // .pdpb.TransferLeader transfer_leader = 3;
  bool has_transfer_leader() const;
  void clear_transfer_leader();
  static const int kTransferLeaderFieldNumber = 3;
  const ::pdpb::TransferLeader& transfer_leader() const;
  ::pdpb::TransferLeader* release_transfer_leader();
  ::pdpb::TransferLeader* mutable_transfer_leader();
  void set_allocated_transfer_leader(::pdpb::TransferLeader* transfer_leader);

  // .metapb.RegionEpoch region_epoch = 5;
  bool has_region_epoch() const;
  void clear_region_epoch();
  static const int kRegionEpochFieldNumber = 5;
  const ::metapb::RegionEpoch& region_epoch() const;
  ::metapb::RegionEpoch* release_region_epoch();
  ::metapb::RegionEpoch* mutable_region_epoch();
  void set_allocated_region_epoch(::metapb::RegionEpoch* region_epoch);

  // .metapb.Peer target_peer = 6;
  bool has_target_peer() const;
  void clear_target_peer();
  static const int kTargetPeerFieldNumber = 6;
  const ::metapb::Peer& target_peer() const;
  ::metapb::Peer* release_target_peer();
  ::metapb::Peer* mutable_target_peer();
  void set_allocated_target_peer(::metapb::Peer* target_peer);

  // .pdpb.Merge merge = 7;
  bool has_merge() const;
  void clear_merge();
  static const int kMergeFieldNumber = 7;
  const ::pdpb::Merge& merge() const;
  ::pdpb::Merge* release_merge();
  ::pdpb::Merge* mutable_merge();
  void set_allocated_merge(::pdpb::Merge* merge);

  // .pdpb.SplitRegion split_region = 8;
  bool has_split_region() const;
  void clear_split_region();
  static const int kSplitRegionFieldNumber = 8;
  const ::pdpb::SplitRegion& split_region() const;
  ::pdpb::SplitRegion* release_split_region();
  ::pdpb::SplitRegion* mutable_split_region();
  void set_allocated_split_region(::pdpb::SplitRegion* split_region);

  // uint64 region_id = 4;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 4;
  ::google::protobuf::uint64 region_id() const;
  void set_region_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.RegionHeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  ::pdpb::ChangePeer* change_peer_;
  ::pdpb::TransferLeader* transfer_leader_;
  ::metapb::RegionEpoch* region_epoch_;
  ::metapb::Peer* target_peer_;
  ::pdpb::Merge* merge_;
  ::pdpb::SplitRegion* split_region_;
  ::google::protobuf::uint64 region_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsRegionHeartbeatResponseImpl();
};
// -------------------------------------------------------------------

class AskSplitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.AskSplitRequest) */ {
 public:
  AskSplitRequest();
  virtual ~AskSplitRequest();

  AskSplitRequest(const AskSplitRequest& from);

  inline AskSplitRequest& operator=(const AskSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskSplitRequest(AskSplitRequest&& from) noexcept
    : AskSplitRequest() {
    *this = ::std::move(from);
  }

  inline AskSplitRequest& operator=(AskSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AskSplitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskSplitRequest* internal_default_instance() {
    return reinterpret_cast<const AskSplitRequest*>(
               &_AskSplitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(AskSplitRequest* other);
  friend void swap(AskSplitRequest& a, AskSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskSplitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AskSplitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskSplitRequest& from);
  void MergeFrom(const AskSplitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .metapb.Region region = 2;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 2;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // @@protoc_insertion_point(class_scope:pdpb.AskSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::metapb::Region* region_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsAskSplitRequestImpl();
};
// -------------------------------------------------------------------

class AskSplitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.AskSplitResponse) */ {
 public:
  AskSplitResponse();
  virtual ~AskSplitResponse();

  AskSplitResponse(const AskSplitResponse& from);

  inline AskSplitResponse& operator=(const AskSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskSplitResponse(AskSplitResponse&& from) noexcept
    : AskSplitResponse() {
    *this = ::std::move(from);
  }

  inline AskSplitResponse& operator=(AskSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AskSplitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskSplitResponse* internal_default_instance() {
    return reinterpret_cast<const AskSplitResponse*>(
               &_AskSplitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(AskSplitResponse* other);
  friend void swap(AskSplitResponse& a, AskSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskSplitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AskSplitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskSplitResponse& from);
  void MergeFrom(const AskSplitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 new_peer_ids = 3;
  int new_peer_ids_size() const;
  void clear_new_peer_ids();
  static const int kNewPeerIdsFieldNumber = 3;
  ::google::protobuf::uint64 new_peer_ids(int index) const;
  void set_new_peer_ids(int index, ::google::protobuf::uint64 value);
  void add_new_peer_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      new_peer_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_new_peer_ids();

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // uint64 new_region_id = 2;
  void clear_new_region_id();
  static const int kNewRegionIdFieldNumber = 2;
  ::google::protobuf::uint64 new_region_id() const;
  void set_new_region_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.AskSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > new_peer_ids_;
  mutable int _new_peer_ids_cached_byte_size_;
  ::pdpb::ResponseHeader* header_;
  ::google::protobuf::uint64 new_region_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsAskSplitResponseImpl();
};
// -------------------------------------------------------------------

class ReportSplitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.ReportSplitRequest) */ {
 public:
  ReportSplitRequest();
  virtual ~ReportSplitRequest();

  ReportSplitRequest(const ReportSplitRequest& from);

  inline ReportSplitRequest& operator=(const ReportSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportSplitRequest(ReportSplitRequest&& from) noexcept
    : ReportSplitRequest() {
    *this = ::std::move(from);
  }

  inline ReportSplitRequest& operator=(ReportSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportSplitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportSplitRequest* internal_default_instance() {
    return reinterpret_cast<const ReportSplitRequest*>(
               &_ReportSplitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(ReportSplitRequest* other);
  friend void swap(ReportSplitRequest& a, ReportSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportSplitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportSplitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportSplitRequest& from);
  void MergeFrom(const ReportSplitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .metapb.Region left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  const ::metapb::Region& left() const;
  ::metapb::Region* release_left();
  ::metapb::Region* mutable_left();
  void set_allocated_left(::metapb::Region* left);

  // .metapb.Region right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  const ::metapb::Region& right() const;
  ::metapb::Region* release_right();
  ::metapb::Region* mutable_right();
  void set_allocated_right(::metapb::Region* right);

  // @@protoc_insertion_point(class_scope:pdpb.ReportSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::metapb::Region* left_;
  ::metapb::Region* right_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsReportSplitRequestImpl();
};
// -------------------------------------------------------------------

class ReportSplitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.ReportSplitResponse) */ {
 public:
  ReportSplitResponse();
  virtual ~ReportSplitResponse();

  ReportSplitResponse(const ReportSplitResponse& from);

  inline ReportSplitResponse& operator=(const ReportSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportSplitResponse(ReportSplitResponse&& from) noexcept
    : ReportSplitResponse() {
    *this = ::std::move(from);
  }

  inline ReportSplitResponse& operator=(ReportSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportSplitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportSplitResponse* internal_default_instance() {
    return reinterpret_cast<const ReportSplitResponse*>(
               &_ReportSplitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(ReportSplitResponse* other);
  friend void swap(ReportSplitResponse& a, ReportSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportSplitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportSplitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportSplitResponse& from);
  void MergeFrom(const ReportSplitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.ReportSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsReportSplitResponseImpl();
};
// -------------------------------------------------------------------

class AskBatchSplitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.AskBatchSplitRequest) */ {
 public:
  AskBatchSplitRequest();
  virtual ~AskBatchSplitRequest();

  AskBatchSplitRequest(const AskBatchSplitRequest& from);

  inline AskBatchSplitRequest& operator=(const AskBatchSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskBatchSplitRequest(AskBatchSplitRequest&& from) noexcept
    : AskBatchSplitRequest() {
    *this = ::std::move(from);
  }

  inline AskBatchSplitRequest& operator=(AskBatchSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AskBatchSplitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskBatchSplitRequest* internal_default_instance() {
    return reinterpret_cast<const AskBatchSplitRequest*>(
               &_AskBatchSplitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(AskBatchSplitRequest* other);
  friend void swap(AskBatchSplitRequest& a, AskBatchSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskBatchSplitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AskBatchSplitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskBatchSplitRequest& from);
  void MergeFrom(const AskBatchSplitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskBatchSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .metapb.Region region = 2;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 2;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // uint32 split_count = 3;
  void clear_split_count();
  static const int kSplitCountFieldNumber = 3;
  ::google::protobuf::uint32 split_count() const;
  void set_split_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pdpb.AskBatchSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::metapb::Region* region_;
  ::google::protobuf::uint32 split_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsAskBatchSplitRequestImpl();
};
// -------------------------------------------------------------------

class SplitID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.SplitID) */ {
 public:
  SplitID();
  virtual ~SplitID();

  SplitID(const SplitID& from);

  inline SplitID& operator=(const SplitID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplitID(SplitID&& from) noexcept
    : SplitID() {
    *this = ::std::move(from);
  }

  inline SplitID& operator=(SplitID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitID* internal_default_instance() {
    return reinterpret_cast<const SplitID*>(
               &_SplitID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(SplitID* other);
  friend void swap(SplitID& a, SplitID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitID* New() const PROTOBUF_FINAL { return New(NULL); }

  SplitID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SplitID& from);
  void MergeFrom(const SplitID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SplitID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 new_peer_ids = 2;
  int new_peer_ids_size() const;
  void clear_new_peer_ids();
  static const int kNewPeerIdsFieldNumber = 2;
  ::google::protobuf::uint64 new_peer_ids(int index) const;
  void set_new_peer_ids(int index, ::google::protobuf::uint64 value);
  void add_new_peer_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      new_peer_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_new_peer_ids();

  // uint64 new_region_id = 1;
  void clear_new_region_id();
  static const int kNewRegionIdFieldNumber = 1;
  ::google::protobuf::uint64 new_region_id() const;
  void set_new_region_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.SplitID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > new_peer_ids_;
  mutable int _new_peer_ids_cached_byte_size_;
  ::google::protobuf::uint64 new_region_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsSplitIDImpl();
};
// -------------------------------------------------------------------

class AskBatchSplitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.AskBatchSplitResponse) */ {
 public:
  AskBatchSplitResponse();
  virtual ~AskBatchSplitResponse();

  AskBatchSplitResponse(const AskBatchSplitResponse& from);

  inline AskBatchSplitResponse& operator=(const AskBatchSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskBatchSplitResponse(AskBatchSplitResponse&& from) noexcept
    : AskBatchSplitResponse() {
    *this = ::std::move(from);
  }

  inline AskBatchSplitResponse& operator=(AskBatchSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AskBatchSplitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskBatchSplitResponse* internal_default_instance() {
    return reinterpret_cast<const AskBatchSplitResponse*>(
               &_AskBatchSplitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(AskBatchSplitResponse* other);
  friend void swap(AskBatchSplitResponse& a, AskBatchSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskBatchSplitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AskBatchSplitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskBatchSplitResponse& from);
  void MergeFrom(const AskBatchSplitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskBatchSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pdpb.SplitID ids = 2;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 2;
  const ::pdpb::SplitID& ids(int index) const;
  ::pdpb::SplitID* mutable_ids(int index);
  ::pdpb::SplitID* add_ids();
  ::google::protobuf::RepeatedPtrField< ::pdpb::SplitID >*
      mutable_ids();
  const ::google::protobuf::RepeatedPtrField< ::pdpb::SplitID >&
      ids() const;

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.AskBatchSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pdpb::SplitID > ids_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsAskBatchSplitResponseImpl();
};
// -------------------------------------------------------------------

class ReportBatchSplitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.ReportBatchSplitRequest) */ {
 public:
  ReportBatchSplitRequest();
  virtual ~ReportBatchSplitRequest();

  ReportBatchSplitRequest(const ReportBatchSplitRequest& from);

  inline ReportBatchSplitRequest& operator=(const ReportBatchSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportBatchSplitRequest(ReportBatchSplitRequest&& from) noexcept
    : ReportBatchSplitRequest() {
    *this = ::std::move(from);
  }

  inline ReportBatchSplitRequest& operator=(ReportBatchSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportBatchSplitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportBatchSplitRequest* internal_default_instance() {
    return reinterpret_cast<const ReportBatchSplitRequest*>(
               &_ReportBatchSplitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(ReportBatchSplitRequest* other);
  friend void swap(ReportBatchSplitRequest& a, ReportBatchSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportBatchSplitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportBatchSplitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportBatchSplitRequest& from);
  void MergeFrom(const ReportBatchSplitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportBatchSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Region regions = 2;
  int regions_size() const;
  void clear_regions();
  static const int kRegionsFieldNumber = 2;
  const ::metapb::Region& regions(int index) const;
  ::metapb::Region* mutable_regions(int index);
  ::metapb::Region* add_regions();
  ::google::protobuf::RepeatedPtrField< ::metapb::Region >*
      mutable_regions();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Region >&
      regions() const;

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.ReportBatchSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Region > regions_;
  ::pdpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsReportBatchSplitRequestImpl();
};
// -------------------------------------------------------------------

class ReportBatchSplitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.ReportBatchSplitResponse) */ {
 public:
  ReportBatchSplitResponse();
  virtual ~ReportBatchSplitResponse();

  ReportBatchSplitResponse(const ReportBatchSplitResponse& from);

  inline ReportBatchSplitResponse& operator=(const ReportBatchSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportBatchSplitResponse(ReportBatchSplitResponse&& from) noexcept
    : ReportBatchSplitResponse() {
    *this = ::std::move(from);
  }

  inline ReportBatchSplitResponse& operator=(ReportBatchSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportBatchSplitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportBatchSplitResponse* internal_default_instance() {
    return reinterpret_cast<const ReportBatchSplitResponse*>(
               &_ReportBatchSplitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(ReportBatchSplitResponse* other);
  friend void swap(ReportBatchSplitResponse& a, ReportBatchSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportBatchSplitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportBatchSplitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportBatchSplitResponse& from);
  void MergeFrom(const ReportBatchSplitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportBatchSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.ReportBatchSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsReportBatchSplitResponseImpl();
};
// -------------------------------------------------------------------

class TimeInterval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.TimeInterval) */ {
 public:
  TimeInterval();
  virtual ~TimeInterval();

  TimeInterval(const TimeInterval& from);

  inline TimeInterval& operator=(const TimeInterval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeInterval(TimeInterval&& from) noexcept
    : TimeInterval() {
    *this = ::std::move(from);
  }

  inline TimeInterval& operator=(TimeInterval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeInterval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeInterval* internal_default_instance() {
    return reinterpret_cast<const TimeInterval*>(
               &_TimeInterval_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(TimeInterval* other);
  friend void swap(TimeInterval& a, TimeInterval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeInterval* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeInterval* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeInterval& from);
  void MergeFrom(const TimeInterval& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeInterval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 start_timestamp = 1;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::google::protobuf::uint64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint64 value);

  // uint64 end_timestamp = 2;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 2;
  ::google::protobuf::uint64 end_timestamp() const;
  void set_end_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.TimeInterval)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 start_timestamp_;
  ::google::protobuf::uint64 end_timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsTimeIntervalImpl();
};
// -------------------------------------------------------------------

class StoreStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.StoreStats) */ {
 public:
  StoreStats();
  virtual ~StoreStats();

  StoreStats(const StoreStats& from);

  inline StoreStats& operator=(const StoreStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StoreStats(StoreStats&& from) noexcept
    : StoreStats() {
    *this = ::std::move(from);
  }

  inline StoreStats& operator=(StoreStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreStats* internal_default_instance() {
    return reinterpret_cast<const StoreStats*>(
               &_StoreStats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(StoreStats* other);
  friend void swap(StoreStats& a, StoreStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StoreStats* New() const PROTOBUF_FINAL { return New(NULL); }

  StoreStats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StoreStats& from);
  void MergeFrom(const StoreStats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StoreStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.TimeInterval interval = 15;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 15;
  const ::pdpb::TimeInterval& interval() const;
  ::pdpb::TimeInterval* release_interval();
  ::pdpb::TimeInterval* mutable_interval();
  void set_allocated_interval(::pdpb::TimeInterval* interval);

  // uint64 store_id = 1;
  void clear_store_id();
  static const int kStoreIdFieldNumber = 1;
  ::google::protobuf::uint64 store_id() const;
  void set_store_id(::google::protobuf::uint64 value);

  // uint64 capacity = 2;
  void clear_capacity();
  static const int kCapacityFieldNumber = 2;
  ::google::protobuf::uint64 capacity() const;
  void set_capacity(::google::protobuf::uint64 value);

  // uint64 available = 3;
  void clear_available();
  static const int kAvailableFieldNumber = 3;
  ::google::protobuf::uint64 available() const;
  void set_available(::google::protobuf::uint64 value);

  // uint32 region_count = 4;
  void clear_region_count();
  static const int kRegionCountFieldNumber = 4;
  ::google::protobuf::uint32 region_count() const;
  void set_region_count(::google::protobuf::uint32 value);

  // uint32 sending_snap_count = 5;
  void clear_sending_snap_count();
  static const int kSendingSnapCountFieldNumber = 5;
  ::google::protobuf::uint32 sending_snap_count() const;
  void set_sending_snap_count(::google::protobuf::uint32 value);

  // uint32 receiving_snap_count = 6;
  void clear_receiving_snap_count();
  static const int kReceivingSnapCountFieldNumber = 6;
  ::google::protobuf::uint32 receiving_snap_count() const;
  void set_receiving_snap_count(::google::protobuf::uint32 value);

  // uint32 start_time = 7;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 7;
  ::google::protobuf::uint32 start_time() const;
  void set_start_time(::google::protobuf::uint32 value);

  // uint32 applying_snap_count = 8;
  void clear_applying_snap_count();
  static const int kApplyingSnapCountFieldNumber = 8;
  ::google::protobuf::uint32 applying_snap_count() const;
  void set_applying_snap_count(::google::protobuf::uint32 value);

  // bool is_busy = 9;
  void clear_is_busy();
  static const int kIsBusyFieldNumber = 9;
  bool is_busy() const;
  void set_is_busy(bool value);

  // uint64 used_size = 10;
  void clear_used_size();
  static const int kUsedSizeFieldNumber = 10;
  ::google::protobuf::uint64 used_size() const;
  void set_used_size(::google::protobuf::uint64 value);

  // uint64 bytes_written = 11;
  void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 11;
  ::google::protobuf::uint64 bytes_written() const;
  void set_bytes_written(::google::protobuf::uint64 value);

  // uint64 keys_written = 12;
  void clear_keys_written();
  static const int kKeysWrittenFieldNumber = 12;
  ::google::protobuf::uint64 keys_written() const;
  void set_keys_written(::google::protobuf::uint64 value);

  // uint64 bytes_read = 13;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 13;
  ::google::protobuf::uint64 bytes_read() const;
  void set_bytes_read(::google::protobuf::uint64 value);

  // uint64 keys_read = 14;
  void clear_keys_read();
  static const int kKeysReadFieldNumber = 14;
  ::google::protobuf::uint64 keys_read() const;
  void set_keys_read(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.StoreStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::TimeInterval* interval_;
  ::google::protobuf::uint64 store_id_;
  ::google::protobuf::uint64 capacity_;
  ::google::protobuf::uint64 available_;
  ::google::protobuf::uint32 region_count_;
  ::google::protobuf::uint32 sending_snap_count_;
  ::google::protobuf::uint32 receiving_snap_count_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 applying_snap_count_;
  bool is_busy_;
  ::google::protobuf::uint64 used_size_;
  ::google::protobuf::uint64 bytes_written_;
  ::google::protobuf::uint64 keys_written_;
  ::google::protobuf::uint64 bytes_read_;
  ::google::protobuf::uint64 keys_read_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsStoreStatsImpl();
};
// -------------------------------------------------------------------

class StoreHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.StoreHeartbeatRequest) */ {
 public:
  StoreHeartbeatRequest();
  virtual ~StoreHeartbeatRequest();

  StoreHeartbeatRequest(const StoreHeartbeatRequest& from);

  inline StoreHeartbeatRequest& operator=(const StoreHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StoreHeartbeatRequest(StoreHeartbeatRequest&& from) noexcept
    : StoreHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline StoreHeartbeatRequest& operator=(StoreHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreHeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const StoreHeartbeatRequest*>(
               &_StoreHeartbeatRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(StoreHeartbeatRequest* other);
  friend void swap(StoreHeartbeatRequest& a, StoreHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StoreHeartbeatRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StoreHeartbeatRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StoreHeartbeatRequest& from);
  void MergeFrom(const StoreHeartbeatRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StoreHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .pdpb.StoreStats stats = 2;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 2;
  const ::pdpb::StoreStats& stats() const;
  ::pdpb::StoreStats* release_stats();
  ::pdpb::StoreStats* mutable_stats();
  void set_allocated_stats(::pdpb::StoreStats* stats);

  // @@protoc_insertion_point(class_scope:pdpb.StoreHeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::pdpb::StoreStats* stats_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsStoreHeartbeatRequestImpl();
};
// -------------------------------------------------------------------

class StoreHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.StoreHeartbeatResponse) */ {
 public:
  StoreHeartbeatResponse();
  virtual ~StoreHeartbeatResponse();

  StoreHeartbeatResponse(const StoreHeartbeatResponse& from);

  inline StoreHeartbeatResponse& operator=(const StoreHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StoreHeartbeatResponse(StoreHeartbeatResponse&& from) noexcept
    : StoreHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline StoreHeartbeatResponse& operator=(StoreHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreHeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const StoreHeartbeatResponse*>(
               &_StoreHeartbeatResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(StoreHeartbeatResponse* other);
  friend void swap(StoreHeartbeatResponse& a, StoreHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StoreHeartbeatResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StoreHeartbeatResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StoreHeartbeatResponse& from);
  void MergeFrom(const StoreHeartbeatResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StoreHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.StoreHeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsStoreHeartbeatResponseImpl();
};
// -------------------------------------------------------------------

class ScatterRegionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.ScatterRegionRequest) */ {
 public:
  ScatterRegionRequest();
  virtual ~ScatterRegionRequest();

  ScatterRegionRequest(const ScatterRegionRequest& from);

  inline ScatterRegionRequest& operator=(const ScatterRegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScatterRegionRequest(ScatterRegionRequest&& from) noexcept
    : ScatterRegionRequest() {
    *this = ::std::move(from);
  }

  inline ScatterRegionRequest& operator=(ScatterRegionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScatterRegionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScatterRegionRequest* internal_default_instance() {
    return reinterpret_cast<const ScatterRegionRequest*>(
               &_ScatterRegionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(ScatterRegionRequest* other);
  friend void swap(ScatterRegionRequest& a, ScatterRegionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScatterRegionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ScatterRegionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScatterRegionRequest& from);
  void MergeFrom(const ScatterRegionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScatterRegionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .metapb.Region region = 3;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 3;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // .metapb.Peer leader = 4;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 4;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* release_leader();
  ::metapb::Peer* mutable_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // uint64 region_id = 2;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 2;
  ::google::protobuf::uint64 region_id() const;
  void set_region_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.ScatterRegionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::metapb::Region* region_;
  ::metapb::Peer* leader_;
  ::google::protobuf::uint64 region_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsScatterRegionRequestImpl();
};
// -------------------------------------------------------------------

class ScatterRegionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.ScatterRegionResponse) */ {
 public:
  ScatterRegionResponse();
  virtual ~ScatterRegionResponse();

  ScatterRegionResponse(const ScatterRegionResponse& from);

  inline ScatterRegionResponse& operator=(const ScatterRegionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScatterRegionResponse(ScatterRegionResponse&& from) noexcept
    : ScatterRegionResponse() {
    *this = ::std::move(from);
  }

  inline ScatterRegionResponse& operator=(ScatterRegionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScatterRegionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScatterRegionResponse* internal_default_instance() {
    return reinterpret_cast<const ScatterRegionResponse*>(
               &_ScatterRegionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(ScatterRegionResponse* other);
  friend void swap(ScatterRegionResponse& a, ScatterRegionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScatterRegionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ScatterRegionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScatterRegionResponse& from);
  void MergeFrom(const ScatterRegionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScatterRegionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.ScatterRegionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsScatterRegionResponseImpl();
};
// -------------------------------------------------------------------

class GetGCSafePointRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetGCSafePointRequest) */ {
 public:
  GetGCSafePointRequest();
  virtual ~GetGCSafePointRequest();

  GetGCSafePointRequest(const GetGCSafePointRequest& from);

  inline GetGCSafePointRequest& operator=(const GetGCSafePointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetGCSafePointRequest(GetGCSafePointRequest&& from) noexcept
    : GetGCSafePointRequest() {
    *this = ::std::move(from);
  }

  inline GetGCSafePointRequest& operator=(GetGCSafePointRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGCSafePointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetGCSafePointRequest* internal_default_instance() {
    return reinterpret_cast<const GetGCSafePointRequest*>(
               &_GetGCSafePointRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(GetGCSafePointRequest* other);
  friend void swap(GetGCSafePointRequest& a, GetGCSafePointRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetGCSafePointRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetGCSafePointRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetGCSafePointRequest& from);
  void MergeFrom(const GetGCSafePointRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetGCSafePointRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.GetGCSafePointRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetGCSafePointRequestImpl();
};
// -------------------------------------------------------------------

class GetGCSafePointResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.GetGCSafePointResponse) */ {
 public:
  GetGCSafePointResponse();
  virtual ~GetGCSafePointResponse();

  GetGCSafePointResponse(const GetGCSafePointResponse& from);

  inline GetGCSafePointResponse& operator=(const GetGCSafePointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetGCSafePointResponse(GetGCSafePointResponse&& from) noexcept
    : GetGCSafePointResponse() {
    *this = ::std::move(from);
  }

  inline GetGCSafePointResponse& operator=(GetGCSafePointResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGCSafePointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetGCSafePointResponse* internal_default_instance() {
    return reinterpret_cast<const GetGCSafePointResponse*>(
               &_GetGCSafePointResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(GetGCSafePointResponse* other);
  friend void swap(GetGCSafePointResponse& a, GetGCSafePointResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetGCSafePointResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetGCSafePointResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetGCSafePointResponse& from);
  void MergeFrom(const GetGCSafePointResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetGCSafePointResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // uint64 safe_point = 2;
  void clear_safe_point();
  static const int kSafePointFieldNumber = 2;
  ::google::protobuf::uint64 safe_point() const;
  void set_safe_point(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.GetGCSafePointResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  ::google::protobuf::uint64 safe_point_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsGetGCSafePointResponseImpl();
};
// -------------------------------------------------------------------

class UpdateGCSafePointRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.UpdateGCSafePointRequest) */ {
 public:
  UpdateGCSafePointRequest();
  virtual ~UpdateGCSafePointRequest();

  UpdateGCSafePointRequest(const UpdateGCSafePointRequest& from);

  inline UpdateGCSafePointRequest& operator=(const UpdateGCSafePointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateGCSafePointRequest(UpdateGCSafePointRequest&& from) noexcept
    : UpdateGCSafePointRequest() {
    *this = ::std::move(from);
  }

  inline UpdateGCSafePointRequest& operator=(UpdateGCSafePointRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateGCSafePointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateGCSafePointRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateGCSafePointRequest*>(
               &_UpdateGCSafePointRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(UpdateGCSafePointRequest* other);
  friend void swap(UpdateGCSafePointRequest& a, UpdateGCSafePointRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateGCSafePointRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateGCSafePointRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateGCSafePointRequest& from);
  void MergeFrom(const UpdateGCSafePointRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateGCSafePointRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // uint64 safe_point = 2;
  void clear_safe_point();
  static const int kSafePointFieldNumber = 2;
  ::google::protobuf::uint64 safe_point() const;
  void set_safe_point(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.UpdateGCSafePointRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::google::protobuf::uint64 safe_point_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsUpdateGCSafePointRequestImpl();
};
// -------------------------------------------------------------------

class UpdateGCSafePointResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.UpdateGCSafePointResponse) */ {
 public:
  UpdateGCSafePointResponse();
  virtual ~UpdateGCSafePointResponse();

  UpdateGCSafePointResponse(const UpdateGCSafePointResponse& from);

  inline UpdateGCSafePointResponse& operator=(const UpdateGCSafePointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateGCSafePointResponse(UpdateGCSafePointResponse&& from) noexcept
    : UpdateGCSafePointResponse() {
    *this = ::std::move(from);
  }

  inline UpdateGCSafePointResponse& operator=(UpdateGCSafePointResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateGCSafePointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateGCSafePointResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateGCSafePointResponse*>(
               &_UpdateGCSafePointResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(UpdateGCSafePointResponse* other);
  friend void swap(UpdateGCSafePointResponse& a, UpdateGCSafePointResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateGCSafePointResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateGCSafePointResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateGCSafePointResponse& from);
  void MergeFrom(const UpdateGCSafePointResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateGCSafePointResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // uint64 new_safe_point = 2;
  void clear_new_safe_point();
  static const int kNewSafePointFieldNumber = 2;
  ::google::protobuf::uint64 new_safe_point() const;
  void set_new_safe_point(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pdpb.UpdateGCSafePointResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::ResponseHeader* header_;
  ::google::protobuf::uint64 new_safe_point_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsUpdateGCSafePointResponseImpl();
};
// -------------------------------------------------------------------

class SyncRegionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.SyncRegionRequest) */ {
 public:
  SyncRegionRequest();
  virtual ~SyncRegionRequest();

  SyncRegionRequest(const SyncRegionRequest& from);

  inline SyncRegionRequest& operator=(const SyncRegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyncRegionRequest(SyncRegionRequest&& from) noexcept
    : SyncRegionRequest() {
    *this = ::std::move(from);
  }

  inline SyncRegionRequest& operator=(SyncRegionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncRegionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncRegionRequest* internal_default_instance() {
    return reinterpret_cast<const SyncRegionRequest*>(
               &_SyncRegionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(SyncRegionRequest* other);
  friend void swap(SyncRegionRequest& a, SyncRegionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyncRegionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SyncRegionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SyncRegionRequest& from);
  void MergeFrom(const SyncRegionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SyncRegionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pdpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::RequestHeader& header() const;
  ::pdpb::RequestHeader* release_header();
  ::pdpb::RequestHeader* mutable_header();
  void set_allocated_header(::pdpb::RequestHeader* header);

  // .pdpb.Member member = 2;
  bool has_member() const;
  void clear_member();
  static const int kMemberFieldNumber = 2;
  const ::pdpb::Member& member() const;
  ::pdpb::Member* release_member();
  ::pdpb::Member* mutable_member();
  void set_allocated_member(::pdpb::Member* member);

  // @@protoc_insertion_point(class_scope:pdpb.SyncRegionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pdpb::RequestHeader* header_;
  ::pdpb::Member* member_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsSyncRegionRequestImpl();
};
// -------------------------------------------------------------------

class SyncRegionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pdpb.SyncRegionResponse) */ {
 public:
  SyncRegionResponse();
  virtual ~SyncRegionResponse();

  SyncRegionResponse(const SyncRegionResponse& from);

  inline SyncRegionResponse& operator=(const SyncRegionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyncRegionResponse(SyncRegionResponse&& from) noexcept
    : SyncRegionResponse() {
    *this = ::std::move(from);
  }

  inline SyncRegionResponse& operator=(SyncRegionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncRegionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncRegionResponse* internal_default_instance() {
    return reinterpret_cast<const SyncRegionResponse*>(
               &_SyncRegionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(SyncRegionResponse* other);
  friend void swap(SyncRegionResponse& a, SyncRegionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyncRegionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SyncRegionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SyncRegionResponse& from);
  void MergeFrom(const SyncRegionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SyncRegionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Region regions = 2;
  int regions_size() const;
  void clear_regions();
  static const int kRegionsFieldNumber = 2;
  const ::metapb::Region& regions(int index) const;
  ::metapb::Region* mutable_regions(int index);
  ::metapb::Region* add_regions();
  ::google::protobuf::RepeatedPtrField< ::metapb::Region >*
      mutable_regions();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Region >&
      regions() const;

  // .pdpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::pdpb::ResponseHeader& header() const;
  ::pdpb::ResponseHeader* release_header();
  ::pdpb::ResponseHeader* mutable_header();
  void set_allocated_header(::pdpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:pdpb.SyncRegionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Region > regions_;
  ::pdpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_pdpb_2eproto::TableStruct;
  friend void ::protobuf_pdpb_2eproto::InitDefaultsSyncRegionResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestHeader

// uint64 cluster_id = 1;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:pdpb.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.RequestHeader.cluster_id)
}

// -------------------------------------------------------------------

// ResponseHeader

// uint64 cluster_id = 1;
inline void ResponseHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:pdpb.ResponseHeader.cluster_id)
  return cluster_id_;
}
inline void ResponseHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.ResponseHeader.cluster_id)
}

// .pdpb.Error error = 2;
inline bool ResponseHeader::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ResponseHeader::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::pdpb::Error& ResponseHeader::error() const {
  const ::pdpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:pdpb.ResponseHeader.error)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::Error*>(
      &::pdpb::_Error_default_instance_);
}
inline ::pdpb::Error* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:pdpb.ResponseHeader.error)
  
  ::pdpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::pdpb::Error* ResponseHeader::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::pdpb::Error;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ResponseHeader.error)
  return error_;
}
inline void ResponseHeader::set_allocated_error(::pdpb::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ResponseHeader.error)
}

// -------------------------------------------------------------------

// Error

// .pdpb.ErrorType type = 1;
inline void Error::clear_type() {
  type_ = 0;
}
inline ::pdpb::ErrorType Error::type() const {
  // @@protoc_insertion_point(field_get:pdpb.Error.type)
  return static_cast< ::pdpb::ErrorType >(type_);
}
inline void Error::set_type(::pdpb::ErrorType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:pdpb.Error.type)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:pdpb.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pdpb.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pdpb.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pdpb.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pdpb.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:pdpb.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:pdpb.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:pdpb.Error.message)
}

// -------------------------------------------------------------------

// TsoRequest

// .pdpb.RequestHeader header = 1;
inline bool TsoRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TsoRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& TsoRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.TsoRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* TsoRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.TsoRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* TsoRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.TsoRequest.header)
  return header_;
}
inline void TsoRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.TsoRequest.header)
}

// uint32 count = 2;
inline void TsoRequest::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 TsoRequest::count() const {
  // @@protoc_insertion_point(field_get:pdpb.TsoRequest.count)
  return count_;
}
inline void TsoRequest::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:pdpb.TsoRequest.count)
}

// -------------------------------------------------------------------

// Timestamp

// int64 physical = 1;
inline void Timestamp::clear_physical() {
  physical_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::physical() const {
  // @@protoc_insertion_point(field_get:pdpb.Timestamp.physical)
  return physical_;
}
inline void Timestamp::set_physical(::google::protobuf::int64 value) {
  
  physical_ = value;
  // @@protoc_insertion_point(field_set:pdpb.Timestamp.physical)
}

// int64 logical = 2;
inline void Timestamp::clear_logical() {
  logical_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::logical() const {
  // @@protoc_insertion_point(field_get:pdpb.Timestamp.logical)
  return logical_;
}
inline void Timestamp::set_logical(::google::protobuf::int64 value) {
  
  logical_ = value;
  // @@protoc_insertion_point(field_set:pdpb.Timestamp.logical)
}

// -------------------------------------------------------------------

// TsoResponse

// .pdpb.ResponseHeader header = 1;
inline bool TsoResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TsoResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& TsoResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.TsoResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* TsoResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.TsoResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* TsoResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.TsoResponse.header)
  return header_;
}
inline void TsoResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.TsoResponse.header)
}

// uint32 count = 2;
inline void TsoResponse::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 TsoResponse::count() const {
  // @@protoc_insertion_point(field_get:pdpb.TsoResponse.count)
  return count_;
}
inline void TsoResponse::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:pdpb.TsoResponse.count)
}

// .pdpb.Timestamp timestamp = 3;
inline bool TsoResponse::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void TsoResponse::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) {
    delete timestamp_;
  }
  timestamp_ = NULL;
}
inline const ::pdpb::Timestamp& TsoResponse::timestamp() const {
  const ::pdpb::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:pdpb.TsoResponse.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::Timestamp*>(
      &::pdpb::_Timestamp_default_instance_);
}
inline ::pdpb::Timestamp* TsoResponse::release_timestamp() {
  // @@protoc_insertion_point(field_release:pdpb.TsoResponse.timestamp)
  
  ::pdpb::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::pdpb::Timestamp* TsoResponse::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::pdpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.TsoResponse.timestamp)
  return timestamp_;
}
inline void TsoResponse::set_allocated_timestamp(::pdpb::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timestamp_;
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:pdpb.TsoResponse.timestamp)
}

// -------------------------------------------------------------------

// BootstrapRequest

// .pdpb.RequestHeader header = 1;
inline bool BootstrapRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void BootstrapRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& BootstrapRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.BootstrapRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* BootstrapRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.BootstrapRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* BootstrapRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.BootstrapRequest.header)
  return header_;
}
inline void BootstrapRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.BootstrapRequest.header)
}

// .metapb.Store store = 2;
inline bool BootstrapRequest::has_store() const {
  return this != internal_default_instance() && store_ != NULL;
}
inline const ::metapb::Store& BootstrapRequest::store() const {
  const ::metapb::Store* p = store_;
  // @@protoc_insertion_point(field_get:pdpb.BootstrapRequest.store)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Store*>(
      &::metapb::_Store_default_instance_);
}
inline ::metapb::Store* BootstrapRequest::release_store() {
  // @@protoc_insertion_point(field_release:pdpb.BootstrapRequest.store)
  
  ::metapb::Store* temp = store_;
  store_ = NULL;
  return temp;
}
inline ::metapb::Store* BootstrapRequest::mutable_store() {
  
  if (store_ == NULL) {
    store_ = new ::metapb::Store;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.BootstrapRequest.store)
  return store_;
}
inline void BootstrapRequest::set_allocated_store(::metapb::Store* store) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(store_);
  }
  if (store) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      store = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, store, submessage_arena);
    }
    
  } else {
    
  }
  store_ = store;
  // @@protoc_insertion_point(field_set_allocated:pdpb.BootstrapRequest.store)
}

// .metapb.Region region = 3;
inline bool BootstrapRequest::has_region() const {
  return this != internal_default_instance() && region_ != NULL;
}
inline const ::metapb::Region& BootstrapRequest::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:pdpb.BootstrapRequest.region)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* BootstrapRequest::release_region() {
  // @@protoc_insertion_point(field_release:pdpb.BootstrapRequest.region)
  
  ::metapb::Region* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::metapb::Region* BootstrapRequest::mutable_region() {
  
  if (region_ == NULL) {
    region_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.BootstrapRequest.region)
  return region_;
}
inline void BootstrapRequest::set_allocated_region(::metapb::Region* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_);
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:pdpb.BootstrapRequest.region)
}

// -------------------------------------------------------------------

// BootstrapResponse

// .pdpb.ResponseHeader header = 1;
inline bool BootstrapResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void BootstrapResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& BootstrapResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.BootstrapResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* BootstrapResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.BootstrapResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* BootstrapResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.BootstrapResponse.header)
  return header_;
}
inline void BootstrapResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.BootstrapResponse.header)
}

// -------------------------------------------------------------------

// IsBootstrappedRequest

// .pdpb.RequestHeader header = 1;
inline bool IsBootstrappedRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void IsBootstrappedRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& IsBootstrappedRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.IsBootstrappedRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* IsBootstrappedRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.IsBootstrappedRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* IsBootstrappedRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.IsBootstrappedRequest.header)
  return header_;
}
inline void IsBootstrappedRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.IsBootstrappedRequest.header)
}

// -------------------------------------------------------------------

// IsBootstrappedResponse

// .pdpb.ResponseHeader header = 1;
inline bool IsBootstrappedResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void IsBootstrappedResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& IsBootstrappedResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.IsBootstrappedResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* IsBootstrappedResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.IsBootstrappedResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* IsBootstrappedResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.IsBootstrappedResponse.header)
  return header_;
}
inline void IsBootstrappedResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.IsBootstrappedResponse.header)
}

// bool bootstrapped = 2;
inline void IsBootstrappedResponse::clear_bootstrapped() {
  bootstrapped_ = false;
}
inline bool IsBootstrappedResponse::bootstrapped() const {
  // @@protoc_insertion_point(field_get:pdpb.IsBootstrappedResponse.bootstrapped)
  return bootstrapped_;
}
inline void IsBootstrappedResponse::set_bootstrapped(bool value) {
  
  bootstrapped_ = value;
  // @@protoc_insertion_point(field_set:pdpb.IsBootstrappedResponse.bootstrapped)
}

// -------------------------------------------------------------------

// AllocIDRequest

// .pdpb.RequestHeader header = 1;
inline bool AllocIDRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AllocIDRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& AllocIDRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.AllocIDRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* AllocIDRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.AllocIDRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* AllocIDRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.AllocIDRequest.header)
  return header_;
}
inline void AllocIDRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.AllocIDRequest.header)
}

// -------------------------------------------------------------------

// AllocIDResponse

// .pdpb.ResponseHeader header = 1;
inline bool AllocIDResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AllocIDResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& AllocIDResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.AllocIDResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* AllocIDResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.AllocIDResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* AllocIDResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.AllocIDResponse.header)
  return header_;
}
inline void AllocIDResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.AllocIDResponse.header)
}

// uint64 id = 2;
inline void AllocIDResponse::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AllocIDResponse::id() const {
  // @@protoc_insertion_point(field_get:pdpb.AllocIDResponse.id)
  return id_;
}
inline void AllocIDResponse::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.AllocIDResponse.id)
}

// -------------------------------------------------------------------

// GetStoreRequest

// .pdpb.RequestHeader header = 1;
inline bool GetStoreRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetStoreRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& GetStoreRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetStoreRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* GetStoreRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetStoreRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* GetStoreRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetStoreRequest.header)
  return header_;
}
inline void GetStoreRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetStoreRequest.header)
}

// uint64 store_id = 2;
inline void GetStoreRequest::clear_store_id() {
  store_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetStoreRequest::store_id() const {
  // @@protoc_insertion_point(field_get:pdpb.GetStoreRequest.store_id)
  return store_id_;
}
inline void GetStoreRequest::set_store_id(::google::protobuf::uint64 value) {
  
  store_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.GetStoreRequest.store_id)
}

// -------------------------------------------------------------------

// GetStoreResponse

// .pdpb.ResponseHeader header = 1;
inline bool GetStoreResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetStoreResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& GetStoreResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetStoreResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* GetStoreResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetStoreResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* GetStoreResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetStoreResponse.header)
  return header_;
}
inline void GetStoreResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetStoreResponse.header)
}

// .metapb.Store store = 2;
inline bool GetStoreResponse::has_store() const {
  return this != internal_default_instance() && store_ != NULL;
}
inline const ::metapb::Store& GetStoreResponse::store() const {
  const ::metapb::Store* p = store_;
  // @@protoc_insertion_point(field_get:pdpb.GetStoreResponse.store)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Store*>(
      &::metapb::_Store_default_instance_);
}
inline ::metapb::Store* GetStoreResponse::release_store() {
  // @@protoc_insertion_point(field_release:pdpb.GetStoreResponse.store)
  
  ::metapb::Store* temp = store_;
  store_ = NULL;
  return temp;
}
inline ::metapb::Store* GetStoreResponse::mutable_store() {
  
  if (store_ == NULL) {
    store_ = new ::metapb::Store;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetStoreResponse.store)
  return store_;
}
inline void GetStoreResponse::set_allocated_store(::metapb::Store* store) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(store_);
  }
  if (store) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      store = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, store, submessage_arena);
    }
    
  } else {
    
  }
  store_ = store;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetStoreResponse.store)
}

// -------------------------------------------------------------------

// PutStoreRequest

// .pdpb.RequestHeader header = 1;
inline bool PutStoreRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PutStoreRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& PutStoreRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.PutStoreRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* PutStoreRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.PutStoreRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* PutStoreRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.PutStoreRequest.header)
  return header_;
}
inline void PutStoreRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.PutStoreRequest.header)
}

// .metapb.Store store = 2;
inline bool PutStoreRequest::has_store() const {
  return this != internal_default_instance() && store_ != NULL;
}
inline const ::metapb::Store& PutStoreRequest::store() const {
  const ::metapb::Store* p = store_;
  // @@protoc_insertion_point(field_get:pdpb.PutStoreRequest.store)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Store*>(
      &::metapb::_Store_default_instance_);
}
inline ::metapb::Store* PutStoreRequest::release_store() {
  // @@protoc_insertion_point(field_release:pdpb.PutStoreRequest.store)
  
  ::metapb::Store* temp = store_;
  store_ = NULL;
  return temp;
}
inline ::metapb::Store* PutStoreRequest::mutable_store() {
  
  if (store_ == NULL) {
    store_ = new ::metapb::Store;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.PutStoreRequest.store)
  return store_;
}
inline void PutStoreRequest::set_allocated_store(::metapb::Store* store) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(store_);
  }
  if (store) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      store = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, store, submessage_arena);
    }
    
  } else {
    
  }
  store_ = store;
  // @@protoc_insertion_point(field_set_allocated:pdpb.PutStoreRequest.store)
}

// -------------------------------------------------------------------

// PutStoreResponse

// .pdpb.ResponseHeader header = 1;
inline bool PutStoreResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PutStoreResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& PutStoreResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.PutStoreResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* PutStoreResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.PutStoreResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* PutStoreResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.PutStoreResponse.header)
  return header_;
}
inline void PutStoreResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.PutStoreResponse.header)
}

// -------------------------------------------------------------------

// GetAllStoresRequest

// .pdpb.RequestHeader header = 1;
inline bool GetAllStoresRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetAllStoresRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& GetAllStoresRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetAllStoresRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* GetAllStoresRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetAllStoresRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* GetAllStoresRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetAllStoresRequest.header)
  return header_;
}
inline void GetAllStoresRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetAllStoresRequest.header)
}

// -------------------------------------------------------------------

// GetAllStoresResponse

// .pdpb.ResponseHeader header = 1;
inline bool GetAllStoresResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetAllStoresResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& GetAllStoresResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetAllStoresResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* GetAllStoresResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetAllStoresResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* GetAllStoresResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetAllStoresResponse.header)
  return header_;
}
inline void GetAllStoresResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetAllStoresResponse.header)
}

// repeated .metapb.Store stores = 2;
inline int GetAllStoresResponse::stores_size() const {
  return stores_.size();
}
inline const ::metapb::Store& GetAllStoresResponse::stores(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.GetAllStoresResponse.stores)
  return stores_.Get(index);
}
inline ::metapb::Store* GetAllStoresResponse::mutable_stores(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.GetAllStoresResponse.stores)
  return stores_.Mutable(index);
}
inline ::metapb::Store* GetAllStoresResponse::add_stores() {
  // @@protoc_insertion_point(field_add:pdpb.GetAllStoresResponse.stores)
  return stores_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Store >*
GetAllStoresResponse::mutable_stores() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.GetAllStoresResponse.stores)
  return &stores_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Store >&
GetAllStoresResponse::stores() const {
  // @@protoc_insertion_point(field_list:pdpb.GetAllStoresResponse.stores)
  return stores_;
}

// -------------------------------------------------------------------

// GetRegionRequest

// .pdpb.RequestHeader header = 1;
inline bool GetRegionRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetRegionRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& GetRegionRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetRegionRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* GetRegionRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetRegionRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* GetRegionRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetRegionRequest.header)
  return header_;
}
inline void GetRegionRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetRegionRequest.header)
}

// bytes region_key = 2;
inline void GetRegionRequest::clear_region_key() {
  region_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRegionRequest::region_key() const {
  // @@protoc_insertion_point(field_get:pdpb.GetRegionRequest.region_key)
  return region_key_.GetNoArena();
}
inline void GetRegionRequest::set_region_key(const ::std::string& value) {
  
  region_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pdpb.GetRegionRequest.region_key)
}
#if LANG_CXX11
inline void GetRegionRequest::set_region_key(::std::string&& value) {
  
  region_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pdpb.GetRegionRequest.region_key)
}
#endif
inline void GetRegionRequest::set_region_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  region_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pdpb.GetRegionRequest.region_key)
}
inline void GetRegionRequest::set_region_key(const void* value, size_t size) {
  
  region_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pdpb.GetRegionRequest.region_key)
}
inline ::std::string* GetRegionRequest::mutable_region_key() {
  
  // @@protoc_insertion_point(field_mutable:pdpb.GetRegionRequest.region_key)
  return region_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRegionRequest::release_region_key() {
  // @@protoc_insertion_point(field_release:pdpb.GetRegionRequest.region_key)
  
  return region_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRegionRequest::set_allocated_region_key(::std::string* region_key) {
  if (region_key != NULL) {
    
  } else {
    
  }
  region_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region_key);
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetRegionRequest.region_key)
}

// -------------------------------------------------------------------

// GetRegionResponse

// .pdpb.ResponseHeader header = 1;
inline bool GetRegionResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetRegionResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& GetRegionResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetRegionResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* GetRegionResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetRegionResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* GetRegionResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetRegionResponse.header)
  return header_;
}
inline void GetRegionResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetRegionResponse.header)
}

// .metapb.Region region = 2;
inline bool GetRegionResponse::has_region() const {
  return this != internal_default_instance() && region_ != NULL;
}
inline const ::metapb::Region& GetRegionResponse::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:pdpb.GetRegionResponse.region)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* GetRegionResponse::release_region() {
  // @@protoc_insertion_point(field_release:pdpb.GetRegionResponse.region)
  
  ::metapb::Region* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::metapb::Region* GetRegionResponse::mutable_region() {
  
  if (region_ == NULL) {
    region_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetRegionResponse.region)
  return region_;
}
inline void GetRegionResponse::set_allocated_region(::metapb::Region* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_);
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetRegionResponse.region)
}

// .metapb.Peer leader = 3;
inline bool GetRegionResponse::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline const ::metapb::Peer& GetRegionResponse::leader() const {
  const ::metapb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:pdpb.GetRegionResponse.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* GetRegionResponse::release_leader() {
  // @@protoc_insertion_point(field_release:pdpb.GetRegionResponse.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline ::metapb::Peer* GetRegionResponse::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetRegionResponse.leader)
  return leader_;
}
inline void GetRegionResponse::set_allocated_leader(::metapb::Peer* leader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(leader_);
  }
  if (leader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetRegionResponse.leader)
}

// -------------------------------------------------------------------

// GetRegionByIDRequest

// .pdpb.RequestHeader header = 1;
inline bool GetRegionByIDRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetRegionByIDRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& GetRegionByIDRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetRegionByIDRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* GetRegionByIDRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetRegionByIDRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* GetRegionByIDRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetRegionByIDRequest.header)
  return header_;
}
inline void GetRegionByIDRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetRegionByIDRequest.header)
}

// uint64 region_id = 2;
inline void GetRegionByIDRequest::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetRegionByIDRequest::region_id() const {
  // @@protoc_insertion_point(field_get:pdpb.GetRegionByIDRequest.region_id)
  return region_id_;
}
inline void GetRegionByIDRequest::set_region_id(::google::protobuf::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.GetRegionByIDRequest.region_id)
}

// -------------------------------------------------------------------

// GetClusterConfigRequest

// .pdpb.RequestHeader header = 1;
inline bool GetClusterConfigRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetClusterConfigRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& GetClusterConfigRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetClusterConfigRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* GetClusterConfigRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetClusterConfigRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* GetClusterConfigRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetClusterConfigRequest.header)
  return header_;
}
inline void GetClusterConfigRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetClusterConfigRequest.header)
}

// -------------------------------------------------------------------

// GetClusterConfigResponse

// .pdpb.ResponseHeader header = 1;
inline bool GetClusterConfigResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetClusterConfigResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& GetClusterConfigResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetClusterConfigResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* GetClusterConfigResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetClusterConfigResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* GetClusterConfigResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetClusterConfigResponse.header)
  return header_;
}
inline void GetClusterConfigResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetClusterConfigResponse.header)
}

// .metapb.Cluster cluster = 2;
inline bool GetClusterConfigResponse::has_cluster() const {
  return this != internal_default_instance() && cluster_ != NULL;
}
inline const ::metapb::Cluster& GetClusterConfigResponse::cluster() const {
  const ::metapb::Cluster* p = cluster_;
  // @@protoc_insertion_point(field_get:pdpb.GetClusterConfigResponse.cluster)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Cluster*>(
      &::metapb::_Cluster_default_instance_);
}
inline ::metapb::Cluster* GetClusterConfigResponse::release_cluster() {
  // @@protoc_insertion_point(field_release:pdpb.GetClusterConfigResponse.cluster)
  
  ::metapb::Cluster* temp = cluster_;
  cluster_ = NULL;
  return temp;
}
inline ::metapb::Cluster* GetClusterConfigResponse::mutable_cluster() {
  
  if (cluster_ == NULL) {
    cluster_ = new ::metapb::Cluster;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetClusterConfigResponse.cluster)
  return cluster_;
}
inline void GetClusterConfigResponse::set_allocated_cluster(::metapb::Cluster* cluster) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cluster_);
  }
  if (cluster) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cluster = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cluster, submessage_arena);
    }
    
  } else {
    
  }
  cluster_ = cluster;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetClusterConfigResponse.cluster)
}

// -------------------------------------------------------------------

// PutClusterConfigRequest

// .pdpb.RequestHeader header = 1;
inline bool PutClusterConfigRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PutClusterConfigRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& PutClusterConfigRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.PutClusterConfigRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* PutClusterConfigRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.PutClusterConfigRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* PutClusterConfigRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.PutClusterConfigRequest.header)
  return header_;
}
inline void PutClusterConfigRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.PutClusterConfigRequest.header)
}

// .metapb.Cluster cluster = 2;
inline bool PutClusterConfigRequest::has_cluster() const {
  return this != internal_default_instance() && cluster_ != NULL;
}
inline const ::metapb::Cluster& PutClusterConfigRequest::cluster() const {
  const ::metapb::Cluster* p = cluster_;
  // @@protoc_insertion_point(field_get:pdpb.PutClusterConfigRequest.cluster)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Cluster*>(
      &::metapb::_Cluster_default_instance_);
}
inline ::metapb::Cluster* PutClusterConfigRequest::release_cluster() {
  // @@protoc_insertion_point(field_release:pdpb.PutClusterConfigRequest.cluster)
  
  ::metapb::Cluster* temp = cluster_;
  cluster_ = NULL;
  return temp;
}
inline ::metapb::Cluster* PutClusterConfigRequest::mutable_cluster() {
  
  if (cluster_ == NULL) {
    cluster_ = new ::metapb::Cluster;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.PutClusterConfigRequest.cluster)
  return cluster_;
}
inline void PutClusterConfigRequest::set_allocated_cluster(::metapb::Cluster* cluster) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cluster_);
  }
  if (cluster) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cluster = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cluster, submessage_arena);
    }
    
  } else {
    
  }
  cluster_ = cluster;
  // @@protoc_insertion_point(field_set_allocated:pdpb.PutClusterConfigRequest.cluster)
}

// -------------------------------------------------------------------

// PutClusterConfigResponse

// .pdpb.ResponseHeader header = 1;
inline bool PutClusterConfigResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PutClusterConfigResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& PutClusterConfigResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.PutClusterConfigResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* PutClusterConfigResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.PutClusterConfigResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* PutClusterConfigResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.PutClusterConfigResponse.header)
  return header_;
}
inline void PutClusterConfigResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.PutClusterConfigResponse.header)
}

// -------------------------------------------------------------------

// Member

// string name = 1;
inline void Member::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Member::name() const {
  // @@protoc_insertion_point(field_get:pdpb.Member.name)
  return name_.GetNoArena();
}
inline void Member::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pdpb.Member.name)
}
#if LANG_CXX11
inline void Member::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pdpb.Member.name)
}
#endif
inline void Member::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pdpb.Member.name)
}
inline void Member::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pdpb.Member.name)
}
inline ::std::string* Member::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pdpb.Member.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Member::release_name() {
  // @@protoc_insertion_point(field_release:pdpb.Member.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Member::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pdpb.Member.name)
}

// uint64 member_id = 2;
inline void Member::clear_member_id() {
  member_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Member::member_id() const {
  // @@protoc_insertion_point(field_get:pdpb.Member.member_id)
  return member_id_;
}
inline void Member::set_member_id(::google::protobuf::uint64 value) {
  
  member_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.Member.member_id)
}

// repeated string peer_urls = 3;
inline int Member::peer_urls_size() const {
  return peer_urls_.size();
}
inline void Member::clear_peer_urls() {
  peer_urls_.Clear();
}
inline const ::std::string& Member::peer_urls(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.Member.peer_urls)
  return peer_urls_.Get(index);
}
inline ::std::string* Member::mutable_peer_urls(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.Member.peer_urls)
  return peer_urls_.Mutable(index);
}
inline void Member::set_peer_urls(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pdpb.Member.peer_urls)
  peer_urls_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Member::set_peer_urls(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pdpb.Member.peer_urls)
  peer_urls_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Member::set_peer_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  peer_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pdpb.Member.peer_urls)
}
inline void Member::set_peer_urls(int index, const char* value, size_t size) {
  peer_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pdpb.Member.peer_urls)
}
inline ::std::string* Member::add_peer_urls() {
  // @@protoc_insertion_point(field_add_mutable:pdpb.Member.peer_urls)
  return peer_urls_.Add();
}
inline void Member::add_peer_urls(const ::std::string& value) {
  peer_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pdpb.Member.peer_urls)
}
#if LANG_CXX11
inline void Member::add_peer_urls(::std::string&& value) {
  peer_urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pdpb.Member.peer_urls)
}
#endif
inline void Member::add_peer_urls(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  peer_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pdpb.Member.peer_urls)
}
inline void Member::add_peer_urls(const char* value, size_t size) {
  peer_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pdpb.Member.peer_urls)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Member::peer_urls() const {
  // @@protoc_insertion_point(field_list:pdpb.Member.peer_urls)
  return peer_urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Member::mutable_peer_urls() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.Member.peer_urls)
  return &peer_urls_;
}

// repeated string client_urls = 4;
inline int Member::client_urls_size() const {
  return client_urls_.size();
}
inline void Member::clear_client_urls() {
  client_urls_.Clear();
}
inline const ::std::string& Member::client_urls(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.Member.client_urls)
  return client_urls_.Get(index);
}
inline ::std::string* Member::mutable_client_urls(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.Member.client_urls)
  return client_urls_.Mutable(index);
}
inline void Member::set_client_urls(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pdpb.Member.client_urls)
  client_urls_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Member::set_client_urls(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pdpb.Member.client_urls)
  client_urls_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Member::set_client_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  client_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pdpb.Member.client_urls)
}
inline void Member::set_client_urls(int index, const char* value, size_t size) {
  client_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pdpb.Member.client_urls)
}
inline ::std::string* Member::add_client_urls() {
  // @@protoc_insertion_point(field_add_mutable:pdpb.Member.client_urls)
  return client_urls_.Add();
}
inline void Member::add_client_urls(const ::std::string& value) {
  client_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pdpb.Member.client_urls)
}
#if LANG_CXX11
inline void Member::add_client_urls(::std::string&& value) {
  client_urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pdpb.Member.client_urls)
}
#endif
inline void Member::add_client_urls(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  client_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pdpb.Member.client_urls)
}
inline void Member::add_client_urls(const char* value, size_t size) {
  client_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pdpb.Member.client_urls)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Member::client_urls() const {
  // @@protoc_insertion_point(field_list:pdpb.Member.client_urls)
  return client_urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Member::mutable_client_urls() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.Member.client_urls)
  return &client_urls_;
}

// int32 leader_priority = 5;
inline void Member::clear_leader_priority() {
  leader_priority_ = 0;
}
inline ::google::protobuf::int32 Member::leader_priority() const {
  // @@protoc_insertion_point(field_get:pdpb.Member.leader_priority)
  return leader_priority_;
}
inline void Member::set_leader_priority(::google::protobuf::int32 value) {
  
  leader_priority_ = value;
  // @@protoc_insertion_point(field_set:pdpb.Member.leader_priority)
}

// -------------------------------------------------------------------

// GetMembersRequest

// .pdpb.RequestHeader header = 1;
inline bool GetMembersRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetMembersRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& GetMembersRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetMembersRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* GetMembersRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetMembersRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* GetMembersRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetMembersRequest.header)
  return header_;
}
inline void GetMembersRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetMembersRequest.header)
}

// -------------------------------------------------------------------

// GetMembersResponse

// .pdpb.ResponseHeader header = 1;
inline bool GetMembersResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetMembersResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& GetMembersResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetMembersResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* GetMembersResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetMembersResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* GetMembersResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetMembersResponse.header)
  return header_;
}
inline void GetMembersResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetMembersResponse.header)
}

// repeated .pdpb.Member members = 2;
inline int GetMembersResponse::members_size() const {
  return members_.size();
}
inline void GetMembersResponse::clear_members() {
  members_.Clear();
}
inline const ::pdpb::Member& GetMembersResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.GetMembersResponse.members)
  return members_.Get(index);
}
inline ::pdpb::Member* GetMembersResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.GetMembersResponse.members)
  return members_.Mutable(index);
}
inline ::pdpb::Member* GetMembersResponse::add_members() {
  // @@protoc_insertion_point(field_add:pdpb.GetMembersResponse.members)
  return members_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pdpb::Member >*
GetMembersResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.GetMembersResponse.members)
  return &members_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pdpb::Member >&
GetMembersResponse::members() const {
  // @@protoc_insertion_point(field_list:pdpb.GetMembersResponse.members)
  return members_;
}

// .pdpb.Member leader = 3;
inline bool GetMembersResponse::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline void GetMembersResponse::clear_leader() {
  if (GetArenaNoVirtual() == NULL && leader_ != NULL) {
    delete leader_;
  }
  leader_ = NULL;
}
inline const ::pdpb::Member& GetMembersResponse::leader() const {
  const ::pdpb::Member* p = leader_;
  // @@protoc_insertion_point(field_get:pdpb.GetMembersResponse.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::Member*>(
      &::pdpb::_Member_default_instance_);
}
inline ::pdpb::Member* GetMembersResponse::release_leader() {
  // @@protoc_insertion_point(field_release:pdpb.GetMembersResponse.leader)
  
  ::pdpb::Member* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline ::pdpb::Member* GetMembersResponse::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::pdpb::Member;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetMembersResponse.leader)
  return leader_;
}
inline void GetMembersResponse::set_allocated_leader(::pdpb::Member* leader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leader_;
  }
  if (leader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetMembersResponse.leader)
}

// .pdpb.Member etcd_leader = 4;
inline bool GetMembersResponse::has_etcd_leader() const {
  return this != internal_default_instance() && etcd_leader_ != NULL;
}
inline void GetMembersResponse::clear_etcd_leader() {
  if (GetArenaNoVirtual() == NULL && etcd_leader_ != NULL) {
    delete etcd_leader_;
  }
  etcd_leader_ = NULL;
}
inline const ::pdpb::Member& GetMembersResponse::etcd_leader() const {
  const ::pdpb::Member* p = etcd_leader_;
  // @@protoc_insertion_point(field_get:pdpb.GetMembersResponse.etcd_leader)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::Member*>(
      &::pdpb::_Member_default_instance_);
}
inline ::pdpb::Member* GetMembersResponse::release_etcd_leader() {
  // @@protoc_insertion_point(field_release:pdpb.GetMembersResponse.etcd_leader)
  
  ::pdpb::Member* temp = etcd_leader_;
  etcd_leader_ = NULL;
  return temp;
}
inline ::pdpb::Member* GetMembersResponse::mutable_etcd_leader() {
  
  if (etcd_leader_ == NULL) {
    etcd_leader_ = new ::pdpb::Member;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetMembersResponse.etcd_leader)
  return etcd_leader_;
}
inline void GetMembersResponse::set_allocated_etcd_leader(::pdpb::Member* etcd_leader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete etcd_leader_;
  }
  if (etcd_leader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      etcd_leader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, etcd_leader, submessage_arena);
    }
    
  } else {
    
  }
  etcd_leader_ = etcd_leader;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetMembersResponse.etcd_leader)
}

// -------------------------------------------------------------------

// PeerStats

// .metapb.Peer peer = 1;
inline bool PeerStats::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::metapb::Peer& PeerStats::peer() const {
  const ::metapb::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:pdpb.PeerStats.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* PeerStats::release_peer() {
  // @@protoc_insertion_point(field_release:pdpb.PeerStats.peer)
  
  ::metapb::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::metapb::Peer* PeerStats::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.PeerStats.peer)
  return peer_;
}
inline void PeerStats::set_allocated_peer(::metapb::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:pdpb.PeerStats.peer)
}

// uint64 down_seconds = 2;
inline void PeerStats::clear_down_seconds() {
  down_seconds_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PeerStats::down_seconds() const {
  // @@protoc_insertion_point(field_get:pdpb.PeerStats.down_seconds)
  return down_seconds_;
}
inline void PeerStats::set_down_seconds(::google::protobuf::uint64 value) {
  
  down_seconds_ = value;
  // @@protoc_insertion_point(field_set:pdpb.PeerStats.down_seconds)
}

// -------------------------------------------------------------------

// RegionHeartbeatRequest

// .pdpb.RequestHeader header = 1;
inline bool RegionHeartbeatRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RegionHeartbeatRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& RegionHeartbeatRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* RegionHeartbeatRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* RegionHeartbeatRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatRequest.header)
  return header_;
}
inline void RegionHeartbeatRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatRequest.header)
}

// .metapb.Region region = 2;
inline bool RegionHeartbeatRequest::has_region() const {
  return this != internal_default_instance() && region_ != NULL;
}
inline const ::metapb::Region& RegionHeartbeatRequest::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.region)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* RegionHeartbeatRequest::release_region() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatRequest.region)
  
  ::metapb::Region* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::metapb::Region* RegionHeartbeatRequest::mutable_region() {
  
  if (region_ == NULL) {
    region_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatRequest.region)
  return region_;
}
inline void RegionHeartbeatRequest::set_allocated_region(::metapb::Region* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_);
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatRequest.region)
}

// .metapb.Peer leader = 3;
inline bool RegionHeartbeatRequest::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline const ::metapb::Peer& RegionHeartbeatRequest::leader() const {
  const ::metapb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* RegionHeartbeatRequest::release_leader() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatRequest.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline ::metapb::Peer* RegionHeartbeatRequest::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatRequest.leader)
  return leader_;
}
inline void RegionHeartbeatRequest::set_allocated_leader(::metapb::Peer* leader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(leader_);
  }
  if (leader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatRequest.leader)
}

// repeated .pdpb.PeerStats down_peers = 4;
inline int RegionHeartbeatRequest::down_peers_size() const {
  return down_peers_.size();
}
inline void RegionHeartbeatRequest::clear_down_peers() {
  down_peers_.Clear();
}
inline const ::pdpb::PeerStats& RegionHeartbeatRequest::down_peers(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.down_peers)
  return down_peers_.Get(index);
}
inline ::pdpb::PeerStats* RegionHeartbeatRequest::mutable_down_peers(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatRequest.down_peers)
  return down_peers_.Mutable(index);
}
inline ::pdpb::PeerStats* RegionHeartbeatRequest::add_down_peers() {
  // @@protoc_insertion_point(field_add:pdpb.RegionHeartbeatRequest.down_peers)
  return down_peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pdpb::PeerStats >*
RegionHeartbeatRequest::mutable_down_peers() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.RegionHeartbeatRequest.down_peers)
  return &down_peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pdpb::PeerStats >&
RegionHeartbeatRequest::down_peers() const {
  // @@protoc_insertion_point(field_list:pdpb.RegionHeartbeatRequest.down_peers)
  return down_peers_;
}

// repeated .metapb.Peer pending_peers = 5;
inline int RegionHeartbeatRequest::pending_peers_size() const {
  return pending_peers_.size();
}
inline const ::metapb::Peer& RegionHeartbeatRequest::pending_peers(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.pending_peers)
  return pending_peers_.Get(index);
}
inline ::metapb::Peer* RegionHeartbeatRequest::mutable_pending_peers(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatRequest.pending_peers)
  return pending_peers_.Mutable(index);
}
inline ::metapb::Peer* RegionHeartbeatRequest::add_pending_peers() {
  // @@protoc_insertion_point(field_add:pdpb.RegionHeartbeatRequest.pending_peers)
  return pending_peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Peer >*
RegionHeartbeatRequest::mutable_pending_peers() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.RegionHeartbeatRequest.pending_peers)
  return &pending_peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Peer >&
RegionHeartbeatRequest::pending_peers() const {
  // @@protoc_insertion_point(field_list:pdpb.RegionHeartbeatRequest.pending_peers)
  return pending_peers_;
}

// uint64 bytes_written = 6;
inline void RegionHeartbeatRequest::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegionHeartbeatRequest::bytes_written() const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.bytes_written)
  return bytes_written_;
}
inline void RegionHeartbeatRequest::set_bytes_written(::google::protobuf::uint64 value) {
  
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:pdpb.RegionHeartbeatRequest.bytes_written)
}

// uint64 bytes_read = 7;
inline void RegionHeartbeatRequest::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegionHeartbeatRequest::bytes_read() const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.bytes_read)
  return bytes_read_;
}
inline void RegionHeartbeatRequest::set_bytes_read(::google::protobuf::uint64 value) {
  
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:pdpb.RegionHeartbeatRequest.bytes_read)
}

// uint64 keys_written = 8;
inline void RegionHeartbeatRequest::clear_keys_written() {
  keys_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegionHeartbeatRequest::keys_written() const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.keys_written)
  return keys_written_;
}
inline void RegionHeartbeatRequest::set_keys_written(::google::protobuf::uint64 value) {
  
  keys_written_ = value;
  // @@protoc_insertion_point(field_set:pdpb.RegionHeartbeatRequest.keys_written)
}

// uint64 keys_read = 9;
inline void RegionHeartbeatRequest::clear_keys_read() {
  keys_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegionHeartbeatRequest::keys_read() const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.keys_read)
  return keys_read_;
}
inline void RegionHeartbeatRequest::set_keys_read(::google::protobuf::uint64 value) {
  
  keys_read_ = value;
  // @@protoc_insertion_point(field_set:pdpb.RegionHeartbeatRequest.keys_read)
}

// uint64 approximate_size = 10;
inline void RegionHeartbeatRequest::clear_approximate_size() {
  approximate_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegionHeartbeatRequest::approximate_size() const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.approximate_size)
  return approximate_size_;
}
inline void RegionHeartbeatRequest::set_approximate_size(::google::protobuf::uint64 value) {
  
  approximate_size_ = value;
  // @@protoc_insertion_point(field_set:pdpb.RegionHeartbeatRequest.approximate_size)
}

// .pdpb.TimeInterval interval = 12;
inline bool RegionHeartbeatRequest::has_interval() const {
  return this != internal_default_instance() && interval_ != NULL;
}
inline void RegionHeartbeatRequest::clear_interval() {
  if (GetArenaNoVirtual() == NULL && interval_ != NULL) {
    delete interval_;
  }
  interval_ = NULL;
}
inline const ::pdpb::TimeInterval& RegionHeartbeatRequest::interval() const {
  const ::pdpb::TimeInterval* p = interval_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.interval)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::TimeInterval*>(
      &::pdpb::_TimeInterval_default_instance_);
}
inline ::pdpb::TimeInterval* RegionHeartbeatRequest::release_interval() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatRequest.interval)
  
  ::pdpb::TimeInterval* temp = interval_;
  interval_ = NULL;
  return temp;
}
inline ::pdpb::TimeInterval* RegionHeartbeatRequest::mutable_interval() {
  
  if (interval_ == NULL) {
    interval_ = new ::pdpb::TimeInterval;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatRequest.interval)
  return interval_;
}
inline void RegionHeartbeatRequest::set_allocated_interval(::pdpb::TimeInterval* interval) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete interval_;
  }
  if (interval) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      interval = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatRequest.interval)
}

// uint64 approximate_keys = 13;
inline void RegionHeartbeatRequest::clear_approximate_keys() {
  approximate_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegionHeartbeatRequest::approximate_keys() const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatRequest.approximate_keys)
  return approximate_keys_;
}
inline void RegionHeartbeatRequest::set_approximate_keys(::google::protobuf::uint64 value) {
  
  approximate_keys_ = value;
  // @@protoc_insertion_point(field_set:pdpb.RegionHeartbeatRequest.approximate_keys)
}

// -------------------------------------------------------------------

// ChangePeer

// .metapb.Peer peer = 1;
inline bool ChangePeer::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::metapb::Peer& ChangePeer::peer() const {
  const ::metapb::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:pdpb.ChangePeer.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* ChangePeer::release_peer() {
  // @@protoc_insertion_point(field_release:pdpb.ChangePeer.peer)
  
  ::metapb::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::metapb::Peer* ChangePeer::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ChangePeer.peer)
  return peer_;
}
inline void ChangePeer::set_allocated_peer(::metapb::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ChangePeer.peer)
}

// .eraftpb.ConfChangeType change_type = 2;
inline void ChangePeer::clear_change_type() {
  change_type_ = 0;
}
inline ::eraftpb::ConfChangeType ChangePeer::change_type() const {
  // @@protoc_insertion_point(field_get:pdpb.ChangePeer.change_type)
  return static_cast< ::eraftpb::ConfChangeType >(change_type_);
}
inline void ChangePeer::set_change_type(::eraftpb::ConfChangeType value) {
  
  change_type_ = value;
  // @@protoc_insertion_point(field_set:pdpb.ChangePeer.change_type)
}

// -------------------------------------------------------------------

// TransferLeader

// .metapb.Peer peer = 1;
inline bool TransferLeader::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::metapb::Peer& TransferLeader::peer() const {
  const ::metapb::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:pdpb.TransferLeader.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* TransferLeader::release_peer() {
  // @@protoc_insertion_point(field_release:pdpb.TransferLeader.peer)
  
  ::metapb::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::metapb::Peer* TransferLeader::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.TransferLeader.peer)
  return peer_;
}
inline void TransferLeader::set_allocated_peer(::metapb::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:pdpb.TransferLeader.peer)
}

// -------------------------------------------------------------------

// Merge

// .metapb.Region target = 1;
inline bool Merge::has_target() const {
  return this != internal_default_instance() && target_ != NULL;
}
inline const ::metapb::Region& Merge::target() const {
  const ::metapb::Region* p = target_;
  // @@protoc_insertion_point(field_get:pdpb.Merge.target)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* Merge::release_target() {
  // @@protoc_insertion_point(field_release:pdpb.Merge.target)
  
  ::metapb::Region* temp = target_;
  target_ = NULL;
  return temp;
}
inline ::metapb::Region* Merge::mutable_target() {
  
  if (target_ == NULL) {
    target_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.Merge.target)
  return target_;
}
inline void Merge::set_allocated_target(::metapb::Region* target) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(target_);
  }
  if (target) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:pdpb.Merge.target)
}

// -------------------------------------------------------------------

// SplitRegion

// .pdpb.CheckPolicy policy = 1;
inline void SplitRegion::clear_policy() {
  policy_ = 0;
}
inline ::pdpb::CheckPolicy SplitRegion::policy() const {
  // @@protoc_insertion_point(field_get:pdpb.SplitRegion.policy)
  return static_cast< ::pdpb::CheckPolicy >(policy_);
}
inline void SplitRegion::set_policy(::pdpb::CheckPolicy value) {
  
  policy_ = value;
  // @@protoc_insertion_point(field_set:pdpb.SplitRegion.policy)
}

// -------------------------------------------------------------------

// RegionHeartbeatResponse

// .pdpb.ResponseHeader header = 1;
inline bool RegionHeartbeatResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RegionHeartbeatResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& RegionHeartbeatResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* RegionHeartbeatResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* RegionHeartbeatResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatResponse.header)
  return header_;
}
inline void RegionHeartbeatResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatResponse.header)
}

// .pdpb.ChangePeer change_peer = 2;
inline bool RegionHeartbeatResponse::has_change_peer() const {
  return this != internal_default_instance() && change_peer_ != NULL;
}
inline void RegionHeartbeatResponse::clear_change_peer() {
  if (GetArenaNoVirtual() == NULL && change_peer_ != NULL) {
    delete change_peer_;
  }
  change_peer_ = NULL;
}
inline const ::pdpb::ChangePeer& RegionHeartbeatResponse::change_peer() const {
  const ::pdpb::ChangePeer* p = change_peer_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatResponse.change_peer)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ChangePeer*>(
      &::pdpb::_ChangePeer_default_instance_);
}
inline ::pdpb::ChangePeer* RegionHeartbeatResponse::release_change_peer() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatResponse.change_peer)
  
  ::pdpb::ChangePeer* temp = change_peer_;
  change_peer_ = NULL;
  return temp;
}
inline ::pdpb::ChangePeer* RegionHeartbeatResponse::mutable_change_peer() {
  
  if (change_peer_ == NULL) {
    change_peer_ = new ::pdpb::ChangePeer;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatResponse.change_peer)
  return change_peer_;
}
inline void RegionHeartbeatResponse::set_allocated_change_peer(::pdpb::ChangePeer* change_peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete change_peer_;
  }
  if (change_peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      change_peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, change_peer, submessage_arena);
    }
    
  } else {
    
  }
  change_peer_ = change_peer;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatResponse.change_peer)
}

// .pdpb.TransferLeader transfer_leader = 3;
inline bool RegionHeartbeatResponse::has_transfer_leader() const {
  return this != internal_default_instance() && transfer_leader_ != NULL;
}
inline void RegionHeartbeatResponse::clear_transfer_leader() {
  if (GetArenaNoVirtual() == NULL && transfer_leader_ != NULL) {
    delete transfer_leader_;
  }
  transfer_leader_ = NULL;
}
inline const ::pdpb::TransferLeader& RegionHeartbeatResponse::transfer_leader() const {
  const ::pdpb::TransferLeader* p = transfer_leader_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatResponse.transfer_leader)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::TransferLeader*>(
      &::pdpb::_TransferLeader_default_instance_);
}
inline ::pdpb::TransferLeader* RegionHeartbeatResponse::release_transfer_leader() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatResponse.transfer_leader)
  
  ::pdpb::TransferLeader* temp = transfer_leader_;
  transfer_leader_ = NULL;
  return temp;
}
inline ::pdpb::TransferLeader* RegionHeartbeatResponse::mutable_transfer_leader() {
  
  if (transfer_leader_ == NULL) {
    transfer_leader_ = new ::pdpb::TransferLeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatResponse.transfer_leader)
  return transfer_leader_;
}
inline void RegionHeartbeatResponse::set_allocated_transfer_leader(::pdpb::TransferLeader* transfer_leader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transfer_leader_;
  }
  if (transfer_leader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transfer_leader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transfer_leader, submessage_arena);
    }
    
  } else {
    
  }
  transfer_leader_ = transfer_leader;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatResponse.transfer_leader)
}

// uint64 region_id = 4;
inline void RegionHeartbeatResponse::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegionHeartbeatResponse::region_id() const {
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatResponse.region_id)
  return region_id_;
}
inline void RegionHeartbeatResponse::set_region_id(::google::protobuf::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.RegionHeartbeatResponse.region_id)
}

// .metapb.RegionEpoch region_epoch = 5;
inline bool RegionHeartbeatResponse::has_region_epoch() const {
  return this != internal_default_instance() && region_epoch_ != NULL;
}
inline const ::metapb::RegionEpoch& RegionHeartbeatResponse::region_epoch() const {
  const ::metapb::RegionEpoch* p = region_epoch_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatResponse.region_epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::RegionEpoch*>(
      &::metapb::_RegionEpoch_default_instance_);
}
inline ::metapb::RegionEpoch* RegionHeartbeatResponse::release_region_epoch() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatResponse.region_epoch)
  
  ::metapb::RegionEpoch* temp = region_epoch_;
  region_epoch_ = NULL;
  return temp;
}
inline ::metapb::RegionEpoch* RegionHeartbeatResponse::mutable_region_epoch() {
  
  if (region_epoch_ == NULL) {
    region_epoch_ = new ::metapb::RegionEpoch;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatResponse.region_epoch)
  return region_epoch_;
}
inline void RegionHeartbeatResponse::set_allocated_region_epoch(::metapb::RegionEpoch* region_epoch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_epoch_);
  }
  if (region_epoch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_epoch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_epoch, submessage_arena);
    }
    
  } else {
    
  }
  region_epoch_ = region_epoch;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatResponse.region_epoch)
}

// .metapb.Peer target_peer = 6;
inline bool RegionHeartbeatResponse::has_target_peer() const {
  return this != internal_default_instance() && target_peer_ != NULL;
}
inline const ::metapb::Peer& RegionHeartbeatResponse::target_peer() const {
  const ::metapb::Peer* p = target_peer_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatResponse.target_peer)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* RegionHeartbeatResponse::release_target_peer() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatResponse.target_peer)
  
  ::metapb::Peer* temp = target_peer_;
  target_peer_ = NULL;
  return temp;
}
inline ::metapb::Peer* RegionHeartbeatResponse::mutable_target_peer() {
  
  if (target_peer_ == NULL) {
    target_peer_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatResponse.target_peer)
  return target_peer_;
}
inline void RegionHeartbeatResponse::set_allocated_target_peer(::metapb::Peer* target_peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(target_peer_);
  }
  if (target_peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target_peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target_peer, submessage_arena);
    }
    
  } else {
    
  }
  target_peer_ = target_peer;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatResponse.target_peer)
}

// .pdpb.Merge merge = 7;
inline bool RegionHeartbeatResponse::has_merge() const {
  return this != internal_default_instance() && merge_ != NULL;
}
inline void RegionHeartbeatResponse::clear_merge() {
  if (GetArenaNoVirtual() == NULL && merge_ != NULL) {
    delete merge_;
  }
  merge_ = NULL;
}
inline const ::pdpb::Merge& RegionHeartbeatResponse::merge() const {
  const ::pdpb::Merge* p = merge_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatResponse.merge)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::Merge*>(
      &::pdpb::_Merge_default_instance_);
}
inline ::pdpb::Merge* RegionHeartbeatResponse::release_merge() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatResponse.merge)
  
  ::pdpb::Merge* temp = merge_;
  merge_ = NULL;
  return temp;
}
inline ::pdpb::Merge* RegionHeartbeatResponse::mutable_merge() {
  
  if (merge_ == NULL) {
    merge_ = new ::pdpb::Merge;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatResponse.merge)
  return merge_;
}
inline void RegionHeartbeatResponse::set_allocated_merge(::pdpb::Merge* merge) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete merge_;
  }
  if (merge) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      merge = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, merge, submessage_arena);
    }
    
  } else {
    
  }
  merge_ = merge;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatResponse.merge)
}

// .pdpb.SplitRegion split_region = 8;
inline bool RegionHeartbeatResponse::has_split_region() const {
  return this != internal_default_instance() && split_region_ != NULL;
}
inline void RegionHeartbeatResponse::clear_split_region() {
  if (GetArenaNoVirtual() == NULL && split_region_ != NULL) {
    delete split_region_;
  }
  split_region_ = NULL;
}
inline const ::pdpb::SplitRegion& RegionHeartbeatResponse::split_region() const {
  const ::pdpb::SplitRegion* p = split_region_;
  // @@protoc_insertion_point(field_get:pdpb.RegionHeartbeatResponse.split_region)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::SplitRegion*>(
      &::pdpb::_SplitRegion_default_instance_);
}
inline ::pdpb::SplitRegion* RegionHeartbeatResponse::release_split_region() {
  // @@protoc_insertion_point(field_release:pdpb.RegionHeartbeatResponse.split_region)
  
  ::pdpb::SplitRegion* temp = split_region_;
  split_region_ = NULL;
  return temp;
}
inline ::pdpb::SplitRegion* RegionHeartbeatResponse::mutable_split_region() {
  
  if (split_region_ == NULL) {
    split_region_ = new ::pdpb::SplitRegion;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.RegionHeartbeatResponse.split_region)
  return split_region_;
}
inline void RegionHeartbeatResponse::set_allocated_split_region(::pdpb::SplitRegion* split_region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete split_region_;
  }
  if (split_region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      split_region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, split_region, submessage_arena);
    }
    
  } else {
    
  }
  split_region_ = split_region;
  // @@protoc_insertion_point(field_set_allocated:pdpb.RegionHeartbeatResponse.split_region)
}

// -------------------------------------------------------------------

// AskSplitRequest

// .pdpb.RequestHeader header = 1;
inline bool AskSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AskSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& AskSplitRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.AskSplitRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* AskSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.AskSplitRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* AskSplitRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.AskSplitRequest.header)
  return header_;
}
inline void AskSplitRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.AskSplitRequest.header)
}

// .metapb.Region region = 2;
inline bool AskSplitRequest::has_region() const {
  return this != internal_default_instance() && region_ != NULL;
}
inline const ::metapb::Region& AskSplitRequest::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:pdpb.AskSplitRequest.region)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* AskSplitRequest::release_region() {
  // @@protoc_insertion_point(field_release:pdpb.AskSplitRequest.region)
  
  ::metapb::Region* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::metapb::Region* AskSplitRequest::mutable_region() {
  
  if (region_ == NULL) {
    region_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.AskSplitRequest.region)
  return region_;
}
inline void AskSplitRequest::set_allocated_region(::metapb::Region* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_);
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:pdpb.AskSplitRequest.region)
}

// -------------------------------------------------------------------

// AskSplitResponse

// .pdpb.ResponseHeader header = 1;
inline bool AskSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AskSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& AskSplitResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.AskSplitResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* AskSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.AskSplitResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* AskSplitResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.AskSplitResponse.header)
  return header_;
}
inline void AskSplitResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.AskSplitResponse.header)
}

// uint64 new_region_id = 2;
inline void AskSplitResponse::clear_new_region_id() {
  new_region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AskSplitResponse::new_region_id() const {
  // @@protoc_insertion_point(field_get:pdpb.AskSplitResponse.new_region_id)
  return new_region_id_;
}
inline void AskSplitResponse::set_new_region_id(::google::protobuf::uint64 value) {
  
  new_region_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.AskSplitResponse.new_region_id)
}

// repeated uint64 new_peer_ids = 3;
inline int AskSplitResponse::new_peer_ids_size() const {
  return new_peer_ids_.size();
}
inline void AskSplitResponse::clear_new_peer_ids() {
  new_peer_ids_.Clear();
}
inline ::google::protobuf::uint64 AskSplitResponse::new_peer_ids(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.AskSplitResponse.new_peer_ids)
  return new_peer_ids_.Get(index);
}
inline void AskSplitResponse::set_new_peer_ids(int index, ::google::protobuf::uint64 value) {
  new_peer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:pdpb.AskSplitResponse.new_peer_ids)
}
inline void AskSplitResponse::add_new_peer_ids(::google::protobuf::uint64 value) {
  new_peer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:pdpb.AskSplitResponse.new_peer_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AskSplitResponse::new_peer_ids() const {
  // @@protoc_insertion_point(field_list:pdpb.AskSplitResponse.new_peer_ids)
  return new_peer_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AskSplitResponse::mutable_new_peer_ids() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.AskSplitResponse.new_peer_ids)
  return &new_peer_ids_;
}

// -------------------------------------------------------------------

// ReportSplitRequest

// .pdpb.RequestHeader header = 1;
inline bool ReportSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReportSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& ReportSplitRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.ReportSplitRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* ReportSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.ReportSplitRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* ReportSplitRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ReportSplitRequest.header)
  return header_;
}
inline void ReportSplitRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ReportSplitRequest.header)
}

// .metapb.Region left = 2;
inline bool ReportSplitRequest::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline const ::metapb::Region& ReportSplitRequest::left() const {
  const ::metapb::Region* p = left_;
  // @@protoc_insertion_point(field_get:pdpb.ReportSplitRequest.left)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* ReportSplitRequest::release_left() {
  // @@protoc_insertion_point(field_release:pdpb.ReportSplitRequest.left)
  
  ::metapb::Region* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::metapb::Region* ReportSplitRequest::mutable_left() {
  
  if (left_ == NULL) {
    left_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ReportSplitRequest.left)
  return left_;
}
inline void ReportSplitRequest::set_allocated_left(::metapb::Region* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(left_);
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ReportSplitRequest.left)
}

// .metapb.Region right = 3;
inline bool ReportSplitRequest::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline const ::metapb::Region& ReportSplitRequest::right() const {
  const ::metapb::Region* p = right_;
  // @@protoc_insertion_point(field_get:pdpb.ReportSplitRequest.right)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* ReportSplitRequest::release_right() {
  // @@protoc_insertion_point(field_release:pdpb.ReportSplitRequest.right)
  
  ::metapb::Region* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::metapb::Region* ReportSplitRequest::mutable_right() {
  
  if (right_ == NULL) {
    right_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ReportSplitRequest.right)
  return right_;
}
inline void ReportSplitRequest::set_allocated_right(::metapb::Region* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(right_);
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ReportSplitRequest.right)
}

// -------------------------------------------------------------------

// ReportSplitResponse

// .pdpb.ResponseHeader header = 1;
inline bool ReportSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReportSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& ReportSplitResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.ReportSplitResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* ReportSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.ReportSplitResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* ReportSplitResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ReportSplitResponse.header)
  return header_;
}
inline void ReportSplitResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ReportSplitResponse.header)
}

// -------------------------------------------------------------------

// AskBatchSplitRequest

// .pdpb.RequestHeader header = 1;
inline bool AskBatchSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AskBatchSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& AskBatchSplitRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.AskBatchSplitRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* AskBatchSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.AskBatchSplitRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* AskBatchSplitRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.AskBatchSplitRequest.header)
  return header_;
}
inline void AskBatchSplitRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.AskBatchSplitRequest.header)
}

// .metapb.Region region = 2;
inline bool AskBatchSplitRequest::has_region() const {
  return this != internal_default_instance() && region_ != NULL;
}
inline const ::metapb::Region& AskBatchSplitRequest::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:pdpb.AskBatchSplitRequest.region)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* AskBatchSplitRequest::release_region() {
  // @@protoc_insertion_point(field_release:pdpb.AskBatchSplitRequest.region)
  
  ::metapb::Region* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::metapb::Region* AskBatchSplitRequest::mutable_region() {
  
  if (region_ == NULL) {
    region_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.AskBatchSplitRequest.region)
  return region_;
}
inline void AskBatchSplitRequest::set_allocated_region(::metapb::Region* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_);
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:pdpb.AskBatchSplitRequest.region)
}

// uint32 split_count = 3;
inline void AskBatchSplitRequest::clear_split_count() {
  split_count_ = 0u;
}
inline ::google::protobuf::uint32 AskBatchSplitRequest::split_count() const {
  // @@protoc_insertion_point(field_get:pdpb.AskBatchSplitRequest.split_count)
  return split_count_;
}
inline void AskBatchSplitRequest::set_split_count(::google::protobuf::uint32 value) {
  
  split_count_ = value;
  // @@protoc_insertion_point(field_set:pdpb.AskBatchSplitRequest.split_count)
}

// -------------------------------------------------------------------

// SplitID

// uint64 new_region_id = 1;
inline void SplitID::clear_new_region_id() {
  new_region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SplitID::new_region_id() const {
  // @@protoc_insertion_point(field_get:pdpb.SplitID.new_region_id)
  return new_region_id_;
}
inline void SplitID::set_new_region_id(::google::protobuf::uint64 value) {
  
  new_region_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.SplitID.new_region_id)
}

// repeated uint64 new_peer_ids = 2;
inline int SplitID::new_peer_ids_size() const {
  return new_peer_ids_.size();
}
inline void SplitID::clear_new_peer_ids() {
  new_peer_ids_.Clear();
}
inline ::google::protobuf::uint64 SplitID::new_peer_ids(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.SplitID.new_peer_ids)
  return new_peer_ids_.Get(index);
}
inline void SplitID::set_new_peer_ids(int index, ::google::protobuf::uint64 value) {
  new_peer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:pdpb.SplitID.new_peer_ids)
}
inline void SplitID::add_new_peer_ids(::google::protobuf::uint64 value) {
  new_peer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:pdpb.SplitID.new_peer_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
SplitID::new_peer_ids() const {
  // @@protoc_insertion_point(field_list:pdpb.SplitID.new_peer_ids)
  return new_peer_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
SplitID::mutable_new_peer_ids() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.SplitID.new_peer_ids)
  return &new_peer_ids_;
}

// -------------------------------------------------------------------

// AskBatchSplitResponse

// .pdpb.ResponseHeader header = 1;
inline bool AskBatchSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AskBatchSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& AskBatchSplitResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.AskBatchSplitResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* AskBatchSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.AskBatchSplitResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* AskBatchSplitResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.AskBatchSplitResponse.header)
  return header_;
}
inline void AskBatchSplitResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.AskBatchSplitResponse.header)
}

// repeated .pdpb.SplitID ids = 2;
inline int AskBatchSplitResponse::ids_size() const {
  return ids_.size();
}
inline void AskBatchSplitResponse::clear_ids() {
  ids_.Clear();
}
inline const ::pdpb::SplitID& AskBatchSplitResponse::ids(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.AskBatchSplitResponse.ids)
  return ids_.Get(index);
}
inline ::pdpb::SplitID* AskBatchSplitResponse::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.AskBatchSplitResponse.ids)
  return ids_.Mutable(index);
}
inline ::pdpb::SplitID* AskBatchSplitResponse::add_ids() {
  // @@protoc_insertion_point(field_add:pdpb.AskBatchSplitResponse.ids)
  return ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pdpb::SplitID >*
AskBatchSplitResponse::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.AskBatchSplitResponse.ids)
  return &ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pdpb::SplitID >&
AskBatchSplitResponse::ids() const {
  // @@protoc_insertion_point(field_list:pdpb.AskBatchSplitResponse.ids)
  return ids_;
}

// -------------------------------------------------------------------

// ReportBatchSplitRequest

// .pdpb.RequestHeader header = 1;
inline bool ReportBatchSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReportBatchSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& ReportBatchSplitRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.ReportBatchSplitRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* ReportBatchSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.ReportBatchSplitRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* ReportBatchSplitRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ReportBatchSplitRequest.header)
  return header_;
}
inline void ReportBatchSplitRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ReportBatchSplitRequest.header)
}

// repeated .metapb.Region regions = 2;
inline int ReportBatchSplitRequest::regions_size() const {
  return regions_.size();
}
inline const ::metapb::Region& ReportBatchSplitRequest::regions(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.ReportBatchSplitRequest.regions)
  return regions_.Get(index);
}
inline ::metapb::Region* ReportBatchSplitRequest::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.ReportBatchSplitRequest.regions)
  return regions_.Mutable(index);
}
inline ::metapb::Region* ReportBatchSplitRequest::add_regions() {
  // @@protoc_insertion_point(field_add:pdpb.ReportBatchSplitRequest.regions)
  return regions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Region >*
ReportBatchSplitRequest::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.ReportBatchSplitRequest.regions)
  return &regions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Region >&
ReportBatchSplitRequest::regions() const {
  // @@protoc_insertion_point(field_list:pdpb.ReportBatchSplitRequest.regions)
  return regions_;
}

// -------------------------------------------------------------------

// ReportBatchSplitResponse

// .pdpb.ResponseHeader header = 1;
inline bool ReportBatchSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReportBatchSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& ReportBatchSplitResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.ReportBatchSplitResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* ReportBatchSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.ReportBatchSplitResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* ReportBatchSplitResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ReportBatchSplitResponse.header)
  return header_;
}
inline void ReportBatchSplitResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ReportBatchSplitResponse.header)
}

// -------------------------------------------------------------------

// TimeInterval

// uint64 start_timestamp = 1;
inline void TimeInterval::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TimeInterval::start_timestamp() const {
  // @@protoc_insertion_point(field_get:pdpb.TimeInterval.start_timestamp)
  return start_timestamp_;
}
inline void TimeInterval::set_start_timestamp(::google::protobuf::uint64 value) {
  
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:pdpb.TimeInterval.start_timestamp)
}

// uint64 end_timestamp = 2;
inline void TimeInterval::clear_end_timestamp() {
  end_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TimeInterval::end_timestamp() const {
  // @@protoc_insertion_point(field_get:pdpb.TimeInterval.end_timestamp)
  return end_timestamp_;
}
inline void TimeInterval::set_end_timestamp(::google::protobuf::uint64 value) {
  
  end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:pdpb.TimeInterval.end_timestamp)
}

// -------------------------------------------------------------------

// StoreStats

// uint64 store_id = 1;
inline void StoreStats::clear_store_id() {
  store_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StoreStats::store_id() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.store_id)
  return store_id_;
}
inline void StoreStats::set_store_id(::google::protobuf::uint64 value) {
  
  store_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.store_id)
}

// uint64 capacity = 2;
inline void StoreStats::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StoreStats::capacity() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.capacity)
  return capacity_;
}
inline void StoreStats::set_capacity(::google::protobuf::uint64 value) {
  
  capacity_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.capacity)
}

// uint64 available = 3;
inline void StoreStats::clear_available() {
  available_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StoreStats::available() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.available)
  return available_;
}
inline void StoreStats::set_available(::google::protobuf::uint64 value) {
  
  available_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.available)
}

// uint32 region_count = 4;
inline void StoreStats::clear_region_count() {
  region_count_ = 0u;
}
inline ::google::protobuf::uint32 StoreStats::region_count() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.region_count)
  return region_count_;
}
inline void StoreStats::set_region_count(::google::protobuf::uint32 value) {
  
  region_count_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.region_count)
}

// uint32 sending_snap_count = 5;
inline void StoreStats::clear_sending_snap_count() {
  sending_snap_count_ = 0u;
}
inline ::google::protobuf::uint32 StoreStats::sending_snap_count() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.sending_snap_count)
  return sending_snap_count_;
}
inline void StoreStats::set_sending_snap_count(::google::protobuf::uint32 value) {
  
  sending_snap_count_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.sending_snap_count)
}

// uint32 receiving_snap_count = 6;
inline void StoreStats::clear_receiving_snap_count() {
  receiving_snap_count_ = 0u;
}
inline ::google::protobuf::uint32 StoreStats::receiving_snap_count() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.receiving_snap_count)
  return receiving_snap_count_;
}
inline void StoreStats::set_receiving_snap_count(::google::protobuf::uint32 value) {
  
  receiving_snap_count_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.receiving_snap_count)
}

// uint32 start_time = 7;
inline void StoreStats::clear_start_time() {
  start_time_ = 0u;
}
inline ::google::protobuf::uint32 StoreStats::start_time() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.start_time)
  return start_time_;
}
inline void StoreStats::set_start_time(::google::protobuf::uint32 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.start_time)
}

// uint32 applying_snap_count = 8;
inline void StoreStats::clear_applying_snap_count() {
  applying_snap_count_ = 0u;
}
inline ::google::protobuf::uint32 StoreStats::applying_snap_count() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.applying_snap_count)
  return applying_snap_count_;
}
inline void StoreStats::set_applying_snap_count(::google::protobuf::uint32 value) {
  
  applying_snap_count_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.applying_snap_count)
}

// bool is_busy = 9;
inline void StoreStats::clear_is_busy() {
  is_busy_ = false;
}
inline bool StoreStats::is_busy() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.is_busy)
  return is_busy_;
}
inline void StoreStats::set_is_busy(bool value) {
  
  is_busy_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.is_busy)
}

// uint64 used_size = 10;
inline void StoreStats::clear_used_size() {
  used_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StoreStats::used_size() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.used_size)
  return used_size_;
}
inline void StoreStats::set_used_size(::google::protobuf::uint64 value) {
  
  used_size_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.used_size)
}

// uint64 bytes_written = 11;
inline void StoreStats::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StoreStats::bytes_written() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.bytes_written)
  return bytes_written_;
}
inline void StoreStats::set_bytes_written(::google::protobuf::uint64 value) {
  
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.bytes_written)
}

// uint64 keys_written = 12;
inline void StoreStats::clear_keys_written() {
  keys_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StoreStats::keys_written() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.keys_written)
  return keys_written_;
}
inline void StoreStats::set_keys_written(::google::protobuf::uint64 value) {
  
  keys_written_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.keys_written)
}

// uint64 bytes_read = 13;
inline void StoreStats::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StoreStats::bytes_read() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.bytes_read)
  return bytes_read_;
}
inline void StoreStats::set_bytes_read(::google::protobuf::uint64 value) {
  
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.bytes_read)
}

// uint64 keys_read = 14;
inline void StoreStats::clear_keys_read() {
  keys_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StoreStats::keys_read() const {
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.keys_read)
  return keys_read_;
}
inline void StoreStats::set_keys_read(::google::protobuf::uint64 value) {
  
  keys_read_ = value;
  // @@protoc_insertion_point(field_set:pdpb.StoreStats.keys_read)
}

// .pdpb.TimeInterval interval = 15;
inline bool StoreStats::has_interval() const {
  return this != internal_default_instance() && interval_ != NULL;
}
inline void StoreStats::clear_interval() {
  if (GetArenaNoVirtual() == NULL && interval_ != NULL) {
    delete interval_;
  }
  interval_ = NULL;
}
inline const ::pdpb::TimeInterval& StoreStats::interval() const {
  const ::pdpb::TimeInterval* p = interval_;
  // @@protoc_insertion_point(field_get:pdpb.StoreStats.interval)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::TimeInterval*>(
      &::pdpb::_TimeInterval_default_instance_);
}
inline ::pdpb::TimeInterval* StoreStats::release_interval() {
  // @@protoc_insertion_point(field_release:pdpb.StoreStats.interval)
  
  ::pdpb::TimeInterval* temp = interval_;
  interval_ = NULL;
  return temp;
}
inline ::pdpb::TimeInterval* StoreStats::mutable_interval() {
  
  if (interval_ == NULL) {
    interval_ = new ::pdpb::TimeInterval;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.StoreStats.interval)
  return interval_;
}
inline void StoreStats::set_allocated_interval(::pdpb::TimeInterval* interval) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete interval_;
  }
  if (interval) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      interval = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:pdpb.StoreStats.interval)
}

// -------------------------------------------------------------------

// StoreHeartbeatRequest

// .pdpb.RequestHeader header = 1;
inline bool StoreHeartbeatRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void StoreHeartbeatRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& StoreHeartbeatRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.StoreHeartbeatRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* StoreHeartbeatRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.StoreHeartbeatRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* StoreHeartbeatRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.StoreHeartbeatRequest.header)
  return header_;
}
inline void StoreHeartbeatRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.StoreHeartbeatRequest.header)
}

// .pdpb.StoreStats stats = 2;
inline bool StoreHeartbeatRequest::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline void StoreHeartbeatRequest::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) {
    delete stats_;
  }
  stats_ = NULL;
}
inline const ::pdpb::StoreStats& StoreHeartbeatRequest::stats() const {
  const ::pdpb::StoreStats* p = stats_;
  // @@protoc_insertion_point(field_get:pdpb.StoreHeartbeatRequest.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::StoreStats*>(
      &::pdpb::_StoreStats_default_instance_);
}
inline ::pdpb::StoreStats* StoreHeartbeatRequest::release_stats() {
  // @@protoc_insertion_point(field_release:pdpb.StoreHeartbeatRequest.stats)
  
  ::pdpb::StoreStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline ::pdpb::StoreStats* StoreHeartbeatRequest::mutable_stats() {
  
  if (stats_ == NULL) {
    stats_ = new ::pdpb::StoreStats;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.StoreHeartbeatRequest.stats)
  return stats_;
}
inline void StoreHeartbeatRequest::set_allocated_stats(::pdpb::StoreStats* stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_;
  }
  if (stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:pdpb.StoreHeartbeatRequest.stats)
}

// -------------------------------------------------------------------

// StoreHeartbeatResponse

// .pdpb.ResponseHeader header = 1;
inline bool StoreHeartbeatResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void StoreHeartbeatResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& StoreHeartbeatResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.StoreHeartbeatResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* StoreHeartbeatResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.StoreHeartbeatResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* StoreHeartbeatResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.StoreHeartbeatResponse.header)
  return header_;
}
inline void StoreHeartbeatResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.StoreHeartbeatResponse.header)
}

// -------------------------------------------------------------------

// ScatterRegionRequest

// .pdpb.RequestHeader header = 1;
inline bool ScatterRegionRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ScatterRegionRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& ScatterRegionRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.ScatterRegionRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* ScatterRegionRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.ScatterRegionRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* ScatterRegionRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ScatterRegionRequest.header)
  return header_;
}
inline void ScatterRegionRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ScatterRegionRequest.header)
}

// uint64 region_id = 2;
inline void ScatterRegionRequest::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ScatterRegionRequest::region_id() const {
  // @@protoc_insertion_point(field_get:pdpb.ScatterRegionRequest.region_id)
  return region_id_;
}
inline void ScatterRegionRequest::set_region_id(::google::protobuf::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:pdpb.ScatterRegionRequest.region_id)
}

// .metapb.Region region = 3;
inline bool ScatterRegionRequest::has_region() const {
  return this != internal_default_instance() && region_ != NULL;
}
inline const ::metapb::Region& ScatterRegionRequest::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:pdpb.ScatterRegionRequest.region)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* ScatterRegionRequest::release_region() {
  // @@protoc_insertion_point(field_release:pdpb.ScatterRegionRequest.region)
  
  ::metapb::Region* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::metapb::Region* ScatterRegionRequest::mutable_region() {
  
  if (region_ == NULL) {
    region_ = new ::metapb::Region;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ScatterRegionRequest.region)
  return region_;
}
inline void ScatterRegionRequest::set_allocated_region(::metapb::Region* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_);
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ScatterRegionRequest.region)
}

// .metapb.Peer leader = 4;
inline bool ScatterRegionRequest::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline const ::metapb::Peer& ScatterRegionRequest::leader() const {
  const ::metapb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:pdpb.ScatterRegionRequest.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* ScatterRegionRequest::release_leader() {
  // @@protoc_insertion_point(field_release:pdpb.ScatterRegionRequest.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline ::metapb::Peer* ScatterRegionRequest::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ScatterRegionRequest.leader)
  return leader_;
}
inline void ScatterRegionRequest::set_allocated_leader(::metapb::Peer* leader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(leader_);
  }
  if (leader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ScatterRegionRequest.leader)
}

// -------------------------------------------------------------------

// ScatterRegionResponse

// .pdpb.ResponseHeader header = 1;
inline bool ScatterRegionResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ScatterRegionResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& ScatterRegionResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.ScatterRegionResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* ScatterRegionResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.ScatterRegionResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* ScatterRegionResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.ScatterRegionResponse.header)
  return header_;
}
inline void ScatterRegionResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.ScatterRegionResponse.header)
}

// -------------------------------------------------------------------

// GetGCSafePointRequest

// .pdpb.RequestHeader header = 1;
inline bool GetGCSafePointRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetGCSafePointRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& GetGCSafePointRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetGCSafePointRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* GetGCSafePointRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetGCSafePointRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* GetGCSafePointRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetGCSafePointRequest.header)
  return header_;
}
inline void GetGCSafePointRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetGCSafePointRequest.header)
}

// -------------------------------------------------------------------

// GetGCSafePointResponse

// .pdpb.ResponseHeader header = 1;
inline bool GetGCSafePointResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetGCSafePointResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& GetGCSafePointResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.GetGCSafePointResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* GetGCSafePointResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.GetGCSafePointResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* GetGCSafePointResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.GetGCSafePointResponse.header)
  return header_;
}
inline void GetGCSafePointResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.GetGCSafePointResponse.header)
}

// uint64 safe_point = 2;
inline void GetGCSafePointResponse::clear_safe_point() {
  safe_point_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetGCSafePointResponse::safe_point() const {
  // @@protoc_insertion_point(field_get:pdpb.GetGCSafePointResponse.safe_point)
  return safe_point_;
}
inline void GetGCSafePointResponse::set_safe_point(::google::protobuf::uint64 value) {
  
  safe_point_ = value;
  // @@protoc_insertion_point(field_set:pdpb.GetGCSafePointResponse.safe_point)
}

// -------------------------------------------------------------------

// UpdateGCSafePointRequest

// .pdpb.RequestHeader header = 1;
inline bool UpdateGCSafePointRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UpdateGCSafePointRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& UpdateGCSafePointRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.UpdateGCSafePointRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* UpdateGCSafePointRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.UpdateGCSafePointRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* UpdateGCSafePointRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.UpdateGCSafePointRequest.header)
  return header_;
}
inline void UpdateGCSafePointRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.UpdateGCSafePointRequest.header)
}

// uint64 safe_point = 2;
inline void UpdateGCSafePointRequest::clear_safe_point() {
  safe_point_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UpdateGCSafePointRequest::safe_point() const {
  // @@protoc_insertion_point(field_get:pdpb.UpdateGCSafePointRequest.safe_point)
  return safe_point_;
}
inline void UpdateGCSafePointRequest::set_safe_point(::google::protobuf::uint64 value) {
  
  safe_point_ = value;
  // @@protoc_insertion_point(field_set:pdpb.UpdateGCSafePointRequest.safe_point)
}

// -------------------------------------------------------------------

// UpdateGCSafePointResponse

// .pdpb.ResponseHeader header = 1;
inline bool UpdateGCSafePointResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UpdateGCSafePointResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& UpdateGCSafePointResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.UpdateGCSafePointResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* UpdateGCSafePointResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.UpdateGCSafePointResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* UpdateGCSafePointResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.UpdateGCSafePointResponse.header)
  return header_;
}
inline void UpdateGCSafePointResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.UpdateGCSafePointResponse.header)
}

// uint64 new_safe_point = 2;
inline void UpdateGCSafePointResponse::clear_new_safe_point() {
  new_safe_point_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UpdateGCSafePointResponse::new_safe_point() const {
  // @@protoc_insertion_point(field_get:pdpb.UpdateGCSafePointResponse.new_safe_point)
  return new_safe_point_;
}
inline void UpdateGCSafePointResponse::set_new_safe_point(::google::protobuf::uint64 value) {
  
  new_safe_point_ = value;
  // @@protoc_insertion_point(field_set:pdpb.UpdateGCSafePointResponse.new_safe_point)
}

// -------------------------------------------------------------------

// SyncRegionRequest

// .pdpb.RequestHeader header = 1;
inline bool SyncRegionRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void SyncRegionRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::RequestHeader& SyncRegionRequest::header() const {
  const ::pdpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.SyncRegionRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::RequestHeader*>(
      &::pdpb::_RequestHeader_default_instance_);
}
inline ::pdpb::RequestHeader* SyncRegionRequest::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.SyncRegionRequest.header)
  
  ::pdpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::RequestHeader* SyncRegionRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.SyncRegionRequest.header)
  return header_;
}
inline void SyncRegionRequest::set_allocated_header(::pdpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.SyncRegionRequest.header)
}

// .pdpb.Member member = 2;
inline bool SyncRegionRequest::has_member() const {
  return this != internal_default_instance() && member_ != NULL;
}
inline void SyncRegionRequest::clear_member() {
  if (GetArenaNoVirtual() == NULL && member_ != NULL) {
    delete member_;
  }
  member_ = NULL;
}
inline const ::pdpb::Member& SyncRegionRequest::member() const {
  const ::pdpb::Member* p = member_;
  // @@protoc_insertion_point(field_get:pdpb.SyncRegionRequest.member)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::Member*>(
      &::pdpb::_Member_default_instance_);
}
inline ::pdpb::Member* SyncRegionRequest::release_member() {
  // @@protoc_insertion_point(field_release:pdpb.SyncRegionRequest.member)
  
  ::pdpb::Member* temp = member_;
  member_ = NULL;
  return temp;
}
inline ::pdpb::Member* SyncRegionRequest::mutable_member() {
  
  if (member_ == NULL) {
    member_ = new ::pdpb::Member;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.SyncRegionRequest.member)
  return member_;
}
inline void SyncRegionRequest::set_allocated_member(::pdpb::Member* member) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete member_;
  }
  if (member) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      member = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, member, submessage_arena);
    }
    
  } else {
    
  }
  member_ = member;
  // @@protoc_insertion_point(field_set_allocated:pdpb.SyncRegionRequest.member)
}

// -------------------------------------------------------------------

// SyncRegionResponse

// .pdpb.ResponseHeader header = 1;
inline bool SyncRegionResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void SyncRegionResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::pdpb::ResponseHeader& SyncRegionResponse::header() const {
  const ::pdpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:pdpb.SyncRegionResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::pdpb::ResponseHeader*>(
      &::pdpb::_ResponseHeader_default_instance_);
}
inline ::pdpb::ResponseHeader* SyncRegionResponse::release_header() {
  // @@protoc_insertion_point(field_release:pdpb.SyncRegionResponse.header)
  
  ::pdpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::pdpb::ResponseHeader* SyncRegionResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::pdpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:pdpb.SyncRegionResponse.header)
  return header_;
}
inline void SyncRegionResponse::set_allocated_header(::pdpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:pdpb.SyncRegionResponse.header)
}

// repeated .metapb.Region regions = 2;
inline int SyncRegionResponse::regions_size() const {
  return regions_.size();
}
inline const ::metapb::Region& SyncRegionResponse::regions(int index) const {
  // @@protoc_insertion_point(field_get:pdpb.SyncRegionResponse.regions)
  return regions_.Get(index);
}
inline ::metapb::Region* SyncRegionResponse::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:pdpb.SyncRegionResponse.regions)
  return regions_.Mutable(index);
}
inline ::metapb::Region* SyncRegionResponse::add_regions() {
  // @@protoc_insertion_point(field_add:pdpb.SyncRegionResponse.regions)
  return regions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Region >*
SyncRegionResponse::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:pdpb.SyncRegionResponse.regions)
  return &regions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Region >&
SyncRegionResponse::regions() const {
  // @@protoc_insertion_point(field_list:pdpb.SyncRegionResponse.regions)
  return regions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pdpb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pdpb::ErrorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pdpb::ErrorType>() {
  return ::pdpb::ErrorType_descriptor();
}
template <> struct is_proto_enum< ::pdpb::CheckPolicy> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pdpb::CheckPolicy>() {
  return ::pdpb::CheckPolicy_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pdpb_2eproto__INCLUDED
